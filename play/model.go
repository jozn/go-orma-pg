// Package models contains the types for schema 'public'.
package models

// GENERATED BY XO. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/csv"
	"errors"
	"fmt"
	"regexp"
	"strings"
)

// Comment represents a row from 'public.comments'.
type Comment struct {
	Id          int    `json:"Id"`          // Id
	UserId      int    `json:"UserId"`      // UserId
	PostId      int    `json:"PostId"`      // PostId
	Text        string `json:"Text"`        // Text
	CreatedTime int    `json:"CreatedTime"` // CreatedTime

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Comment exists in the database.
func (c *Comment) Exists() bool {
	return c._exists
}

// Deleted provides information if the Comment has been deleted from the database.
func (c *Comment) Deleted() bool {
	return c._deleted
}

// Insert inserts the Comment to the database.
func (c *Comment) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if c._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.comments (` +
		`UserId, PostId, Text, CreatedTime` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, c.UserId, c.PostId, c.Text, c.CreatedTime)
	err = db.QueryRow(sqlstr, c.UserId, c.PostId, c.Text, c.CreatedTime).Scan(&c.Id)
	if err != nil {
		return err
	}

	// set existence
	c._exists = true

	return nil
}

// Update updates the Comment in the database.
func (c *Comment) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !c._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if c._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.comments SET (` +
		`UserId, PostId, Text, CreatedTime` +
		`) = ( ` +
		`$1, $2, $3, $4` +
		`) WHERE Id = $5`

	// run query
	XOLog(sqlstr, c.UserId, c.PostId, c.Text, c.CreatedTime, c.Id)
	_, err = db.Exec(sqlstr, c.UserId, c.PostId, c.Text, c.CreatedTime, c.Id)
	return err
}

// Save saves the Comment to the database.
func (c *Comment) Save(db XODB) error {
	if c.Exists() {
		return c.Update(db)
	}

	return c.Insert(db)
}

// Upsert performs an upsert for Comment.
//
// NOTE: PostgreSQL 9.5+ only
func (c *Comment) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if c._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.comments (` +
		`Id, UserId, PostId, Text, CreatedTime` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, UserId, PostId, Text, CreatedTime` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.UserId, EXCLUDED.PostId, EXCLUDED.Text, EXCLUDED.CreatedTime` +
		`)`

	// run query
	XOLog(sqlstr, c.Id, c.UserId, c.PostId, c.Text, c.CreatedTime)
	_, err = db.Exec(sqlstr, c.Id, c.UserId, c.PostId, c.Text, c.CreatedTime)
	if err != nil {
		return err
	}

	// set existence
	c._exists = true

	return nil
}

// Delete deletes the Comment from the database.
func (c *Comment) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !c._exists {
		return nil
	}

	// if deleted, bail
	if c._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.comments WHERE Id = $1`

	// run query
	XOLog(sqlstr, c.Id)
	_, err = db.Exec(sqlstr, c.Id)
	if err != nil {
		return err
	}

	// set deleted
	c._deleted = true

	return nil
}

// FollowingList represents a row from 'public.following_list'.
type FollowingList struct {
	Id           int    `json:"Id"`            // Id
	UserId       int    `json:"UserId"`        // UserId
	ListType     int    `json:"ListType"`      // ListType
	Name         string `json:"Name"`          // Name
	Count        int    `json:"Count"`         // Count
	TRIALCOLUMN6 int16  `json:"TRIAL_COLUMN6"` // TRIAL_COLUMN6
	TRIALCOLUMN7 int16  `json:"TRIAL_COLUMN7"` // TRIAL_COLUMN7
	TRIALCOLUMN8 int    `json:"TRIAL_COLUMN8"` // TRIAL_COLUMN8

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the FollowingList exists in the database.
func (fl *FollowingList) Exists() bool {
	return fl._exists
}

// Deleted provides information if the FollowingList has been deleted from the database.
func (fl *FollowingList) Deleted() bool {
	return fl._deleted
}

// Insert inserts the FollowingList to the database.
func (fl *FollowingList) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if fl._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.following_list (` +
		`Id, ListType, Name, Count, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`) RETURNING UserId`

	// run query
	XOLog(sqlstr, fl.Id, fl.ListType, fl.Name, fl.Count, fl.TRIALCOLUMN6, fl.TRIALCOLUMN7, fl.TRIALCOLUMN8)
	err = db.QueryRow(sqlstr, fl.Id, fl.ListType, fl.Name, fl.Count, fl.TRIALCOLUMN6, fl.TRIALCOLUMN7, fl.TRIALCOLUMN8).Scan(&fl.UserId)
	if err != nil {
		return err
	}

	// set existence
	fl._exists = true

	return nil
}

// Update updates the FollowingList in the database.
func (fl *FollowingList) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !fl._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if fl._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.following_list SET (` +
		`Id, ListType, Name, Count, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`) WHERE UserId = $8`

	// run query
	XOLog(sqlstr, fl.Id, fl.ListType, fl.Name, fl.Count, fl.TRIALCOLUMN6, fl.TRIALCOLUMN7, fl.TRIALCOLUMN8, fl.UserId)
	_, err = db.Exec(sqlstr, fl.Id, fl.ListType, fl.Name, fl.Count, fl.TRIALCOLUMN6, fl.TRIALCOLUMN7, fl.TRIALCOLUMN8, fl.UserId)
	return err
}

// Save saves the FollowingList to the database.
func (fl *FollowingList) Save(db XODB) error {
	if fl.Exists() {
		return fl.Update(db)
	}

	return fl.Insert(db)
}

// Upsert performs an upsert for FollowingList.
//
// NOTE: PostgreSQL 9.5+ only
func (fl *FollowingList) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if fl._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.following_list (` +
		`Id, UserId, ListType, Name, Count, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`) ON CONFLICT (UserId) DO UPDATE SET (` +
		`Id, UserId, ListType, Name, Count, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.UserId, EXCLUDED.ListType, EXCLUDED.Name, EXCLUDED.Count, EXCLUDED.TRIAL_COLUMN6, EXCLUDED.TRIAL_COLUMN7, EXCLUDED.TRIAL_COLUMN8` +
		`)`

	// run query
	XOLog(sqlstr, fl.Id, fl.UserId, fl.ListType, fl.Name, fl.Count, fl.TRIALCOLUMN6, fl.TRIALCOLUMN7, fl.TRIALCOLUMN8)
	_, err = db.Exec(sqlstr, fl.Id, fl.UserId, fl.ListType, fl.Name, fl.Count, fl.TRIALCOLUMN6, fl.TRIALCOLUMN7, fl.TRIALCOLUMN8)
	if err != nil {
		return err
	}

	// set existence
	fl._exists = true

	return nil
}

// Delete deletes the FollowingList from the database.
func (fl *FollowingList) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !fl._exists {
		return nil
	}

	// if deleted, bail
	if fl._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.following_list WHERE UserId = $1`

	// run query
	XOLog(sqlstr, fl.UserId)
	_, err = db.Exec(sqlstr, fl.UserId)
	if err != nil {
		return err
	}

	// set deleted
	fl._deleted = true

	return nil
}

// FollowingListMember represents a row from 'public.following_list_member'.
type FollowingListMember struct {
	Id             int64 `json:"Id"`             // Id
	ListId         int   `json:"ListId"`         // ListId
	UserId         int   `json:"UserId"`         // UserId
	FollowedUserId int   `json:"FollowedUserId"` // FollowedUserId
	FollowType     int16 `json:"FollowType"`     // FollowType
	TRIALCOLUMN6   int64 `json:"TRIAL_COLUMN6"`  // TRIAL_COLUMN6

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the FollowingListMember exists in the database.
func (flm *FollowingListMember) Exists() bool {
	return flm._exists
}

// Deleted provides information if the FollowingListMember has been deleted from the database.
func (flm *FollowingListMember) Deleted() bool {
	return flm._deleted
}

// Insert inserts the FollowingListMember to the database.
func (flm *FollowingListMember) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if flm._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.following_list_member (` +
		`ListId, UserId, FollowedUserId, FollowType, TRIAL_COLUMN6` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, flm.ListId, flm.UserId, flm.FollowedUserId, flm.FollowType, flm.TRIALCOLUMN6)
	err = db.QueryRow(sqlstr, flm.ListId, flm.UserId, flm.FollowedUserId, flm.FollowType, flm.TRIALCOLUMN6).Scan(&flm.Id)
	if err != nil {
		return err
	}

	// set existence
	flm._exists = true

	return nil
}

// Update updates the FollowingListMember in the database.
func (flm *FollowingListMember) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !flm._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if flm._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.following_list_member SET (` +
		`ListId, UserId, FollowedUserId, FollowType, TRIAL_COLUMN6` +
		`) = ( ` +
		`$1, $2, $3, $4, $5` +
		`) WHERE Id = $6`

	// run query
	XOLog(sqlstr, flm.ListId, flm.UserId, flm.FollowedUserId, flm.FollowType, flm.TRIALCOLUMN6, flm.Id)
	_, err = db.Exec(sqlstr, flm.ListId, flm.UserId, flm.FollowedUserId, flm.FollowType, flm.TRIALCOLUMN6, flm.Id)
	return err
}

// Save saves the FollowingListMember to the database.
func (flm *FollowingListMember) Save(db XODB) error {
	if flm.Exists() {
		return flm.Update(db)
	}

	return flm.Insert(db)
}

// Upsert performs an upsert for FollowingListMember.
//
// NOTE: PostgreSQL 9.5+ only
func (flm *FollowingListMember) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if flm._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.following_list_member (` +
		`Id, ListId, UserId, FollowedUserId, FollowType, TRIAL_COLUMN6` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, ListId, UserId, FollowedUserId, FollowType, TRIAL_COLUMN6` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.ListId, EXCLUDED.UserId, EXCLUDED.FollowedUserId, EXCLUDED.FollowType, EXCLUDED.TRIAL_COLUMN6` +
		`)`

	// run query
	XOLog(sqlstr, flm.Id, flm.ListId, flm.UserId, flm.FollowedUserId, flm.FollowType, flm.TRIALCOLUMN6)
	_, err = db.Exec(sqlstr, flm.Id, flm.ListId, flm.UserId, flm.FollowedUserId, flm.FollowType, flm.TRIALCOLUMN6)
	if err != nil {
		return err
	}

	// set existence
	flm._exists = true

	return nil
}

// Delete deletes the FollowingListMember from the database.
func (flm *FollowingListMember) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !flm._exists {
		return nil
	}

	// if deleted, bail
	if flm._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.following_list_member WHERE Id = $1`

	// run query
	XOLog(sqlstr, flm.Id)
	_, err = db.Exec(sqlstr, flm.Id)
	if err != nil {
		return err
	}

	// set deleted
	flm._deleted = true

	return nil
}

// FollowingListMemberHistory represents a row from 'public.following_list_member_history'.
type FollowingListMemberHistory struct {
	Id             int64 `json:"Id"`             // Id
	ListId         int   `json:"ListId"`         // ListId
	UserId         int   `json:"UserId"`         // UserId
	FollowedUserId int   `json:"FollowedUserId"` // FollowedUserId
	FollowType     int16 `json:"FollowType"`     // FollowType
	TRIALCOLUMN6   int64 `json:"TRIAL_COLUMN6"`  // TRIAL_COLUMN6
	TRIALCOLUMN7   int   `json:"TRIAL_COLUMN7"`  // TRIAL_COLUMN7

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the FollowingListMemberHistory exists in the database.
func (flmh *FollowingListMemberHistory) Exists() bool {
	return flmh._exists
}

// Deleted provides information if the FollowingListMemberHistory has been deleted from the database.
func (flmh *FollowingListMemberHistory) Deleted() bool {
	return flmh._deleted
}

// Insert inserts the FollowingListMemberHistory to the database.
func (flmh *FollowingListMemberHistory) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if flmh._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.following_list_member_history (` +
		`ListId, UserId, FollowedUserId, FollowType, TRIAL_COLUMN6, TRIAL_COLUMN7` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, flmh.ListId, flmh.UserId, flmh.FollowedUserId, flmh.FollowType, flmh.TRIALCOLUMN6, flmh.TRIALCOLUMN7)
	err = db.QueryRow(sqlstr, flmh.ListId, flmh.UserId, flmh.FollowedUserId, flmh.FollowType, flmh.TRIALCOLUMN6, flmh.TRIALCOLUMN7).Scan(&flmh.Id)
	if err != nil {
		return err
	}

	// set existence
	flmh._exists = true

	return nil
}

// Update updates the FollowingListMemberHistory in the database.
func (flmh *FollowingListMemberHistory) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !flmh._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if flmh._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.following_list_member_history SET (` +
		`ListId, UserId, FollowedUserId, FollowType, TRIAL_COLUMN6, TRIAL_COLUMN7` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6` +
		`) WHERE Id = $7`

	// run query
	XOLog(sqlstr, flmh.ListId, flmh.UserId, flmh.FollowedUserId, flmh.FollowType, flmh.TRIALCOLUMN6, flmh.TRIALCOLUMN7, flmh.Id)
	_, err = db.Exec(sqlstr, flmh.ListId, flmh.UserId, flmh.FollowedUserId, flmh.FollowType, flmh.TRIALCOLUMN6, flmh.TRIALCOLUMN7, flmh.Id)
	return err
}

// Save saves the FollowingListMemberHistory to the database.
func (flmh *FollowingListMemberHistory) Save(db XODB) error {
	if flmh.Exists() {
		return flmh.Update(db)
	}

	return flmh.Insert(db)
}

// Upsert performs an upsert for FollowingListMemberHistory.
//
// NOTE: PostgreSQL 9.5+ only
func (flmh *FollowingListMemberHistory) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if flmh._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.following_list_member_history (` +
		`Id, ListId, UserId, FollowedUserId, FollowType, TRIAL_COLUMN6, TRIAL_COLUMN7` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, ListId, UserId, FollowedUserId, FollowType, TRIAL_COLUMN6, TRIAL_COLUMN7` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.ListId, EXCLUDED.UserId, EXCLUDED.FollowedUserId, EXCLUDED.FollowType, EXCLUDED.TRIAL_COLUMN6, EXCLUDED.TRIAL_COLUMN7` +
		`)`

	// run query
	XOLog(sqlstr, flmh.Id, flmh.ListId, flmh.UserId, flmh.FollowedUserId, flmh.FollowType, flmh.TRIALCOLUMN6, flmh.TRIALCOLUMN7)
	_, err = db.Exec(sqlstr, flmh.Id, flmh.ListId, flmh.UserId, flmh.FollowedUserId, flmh.FollowType, flmh.TRIALCOLUMN6, flmh.TRIALCOLUMN7)
	if err != nil {
		return err
	}

	// set existence
	flmh._exists = true

	return nil
}

// Delete deletes the FollowingListMemberHistory from the database.
func (flmh *FollowingListMemberHistory) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !flmh._exists {
		return nil
	}

	// if deleted, bail
	if flmh._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.following_list_member_history WHERE Id = $1`

	// run query
	XOLog(sqlstr, flmh.Id)
	_, err = db.Exec(sqlstr, flmh.Id)
	if err != nil {
		return err
	}

	// set deleted
	flmh._deleted = true

	return nil
}

// Like represents a row from 'public.likes'.
type Like struct {
	Id          int   `json:"Id"`          // Id
	PostId      int   `json:"PostId"`      // PostId
	UserId      int   `json:"UserId"`      // UserId
	TypeId      int16 `json:"TypeId"`      // TypeId
	CreatedTime int   `json:"CreatedTime"` // CreatedTime

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Like exists in the database.
func (l *Like) Exists() bool {
	return l._exists
}

// Deleted provides information if the Like has been deleted from the database.
func (l *Like) Deleted() bool {
	return l._deleted
}

// Insert inserts the Like to the database.
func (l *Like) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if l._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.likes (` +
		`PostId, UserId, TypeId, CreatedTime` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, l.PostId, l.UserId, l.TypeId, l.CreatedTime)
	err = db.QueryRow(sqlstr, l.PostId, l.UserId, l.TypeId, l.CreatedTime).Scan(&l.Id)
	if err != nil {
		return err
	}

	// set existence
	l._exists = true

	return nil
}

// Update updates the Like in the database.
func (l *Like) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !l._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if l._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.likes SET (` +
		`PostId, UserId, TypeId, CreatedTime` +
		`) = ( ` +
		`$1, $2, $3, $4` +
		`) WHERE Id = $5`

	// run query
	XOLog(sqlstr, l.PostId, l.UserId, l.TypeId, l.CreatedTime, l.Id)
	_, err = db.Exec(sqlstr, l.PostId, l.UserId, l.TypeId, l.CreatedTime, l.Id)
	return err
}

// Save saves the Like to the database.
func (l *Like) Save(db XODB) error {
	if l.Exists() {
		return l.Update(db)
	}

	return l.Insert(db)
}

// Upsert performs an upsert for Like.
//
// NOTE: PostgreSQL 9.5+ only
func (l *Like) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if l._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.likes (` +
		`Id, PostId, UserId, TypeId, CreatedTime` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, PostId, UserId, TypeId, CreatedTime` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.PostId, EXCLUDED.UserId, EXCLUDED.TypeId, EXCLUDED.CreatedTime` +
		`)`

	// run query
	XOLog(sqlstr, l.Id, l.PostId, l.UserId, l.TypeId, l.CreatedTime)
	_, err = db.Exec(sqlstr, l.Id, l.PostId, l.UserId, l.TypeId, l.CreatedTime)
	if err != nil {
		return err
	}

	// set existence
	l._exists = true

	return nil
}

// Delete deletes the Like from the database.
func (l *Like) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !l._exists {
		return nil
	}

	// if deleted, bail
	if l._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.likes WHERE Id = $1`

	// run query
	XOLog(sqlstr, l.Id)
	_, err = db.Exec(sqlstr, l.Id)
	if err != nil {
		return err
	}

	// set deleted
	l._deleted = true

	return nil
}

// Media represents a row from 'public.media'.
type Media struct {
	Id           int    `json:"Id"`            // Id
	UserId       int    `json:"UserId"`        // UserId
	PostId       int    `json:"PostId"`        // PostId
	AlbumId      int    `json:"AlbumId"`       // AlbumId
	TypeId       int16  `json:"TypeId"`        // TypeId
	TRIALCOLUMN6 int    `json:"TRIAL_COLUMN6"` // TRIAL_COLUMN6
	TRIALCOLUMN7 string `json:"TRIAL_COLUMN7"` // TRIAL_COLUMN7

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Media exists in the database.
func (m *Media) Exists() bool {
	return m._exists
}

// Deleted provides information if the Media has been deleted from the database.
func (m *Media) Deleted() bool {
	return m._deleted
}

// Insert inserts the Media to the database.
func (m *Media) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if m._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.media (` +
		`UserId, PostId, AlbumId, TypeId, TRIAL_COLUMN6, TRIAL_COLUMN7` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, m.UserId, m.PostId, m.AlbumId, m.TypeId, m.TRIALCOLUMN6, m.TRIALCOLUMN7)
	err = db.QueryRow(sqlstr, m.UserId, m.PostId, m.AlbumId, m.TypeId, m.TRIALCOLUMN6, m.TRIALCOLUMN7).Scan(&m.Id)
	if err != nil {
		return err
	}

	// set existence
	m._exists = true

	return nil
}

// Update updates the Media in the database.
func (m *Media) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !m._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if m._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.media SET (` +
		`UserId, PostId, AlbumId, TypeId, TRIAL_COLUMN6, TRIAL_COLUMN7` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6` +
		`) WHERE Id = $7`

	// run query
	XOLog(sqlstr, m.UserId, m.PostId, m.AlbumId, m.TypeId, m.TRIALCOLUMN6, m.TRIALCOLUMN7, m.Id)
	_, err = db.Exec(sqlstr, m.UserId, m.PostId, m.AlbumId, m.TypeId, m.TRIALCOLUMN6, m.TRIALCOLUMN7, m.Id)
	return err
}

// Save saves the Media to the database.
func (m *Media) Save(db XODB) error {
	if m.Exists() {
		return m.Update(db)
	}

	return m.Insert(db)
}

// Upsert performs an upsert for Media.
//
// NOTE: PostgreSQL 9.5+ only
func (m *Media) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if m._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.media (` +
		`Id, UserId, PostId, AlbumId, TypeId, TRIAL_COLUMN6, TRIAL_COLUMN7` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, UserId, PostId, AlbumId, TypeId, TRIAL_COLUMN6, TRIAL_COLUMN7` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.UserId, EXCLUDED.PostId, EXCLUDED.AlbumId, EXCLUDED.TypeId, EXCLUDED.TRIAL_COLUMN6, EXCLUDED.TRIAL_COLUMN7` +
		`)`

	// run query
	XOLog(sqlstr, m.Id, m.UserId, m.PostId, m.AlbumId, m.TypeId, m.TRIALCOLUMN6, m.TRIALCOLUMN7)
	_, err = db.Exec(sqlstr, m.Id, m.UserId, m.PostId, m.AlbumId, m.TypeId, m.TRIALCOLUMN6, m.TRIALCOLUMN7)
	if err != nil {
		return err
	}

	// set existence
	m._exists = true

	return nil
}

// Delete deletes the Media from the database.
func (m *Media) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !m._exists {
		return nil
	}

	// if deleted, bail
	if m._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.media WHERE Id = $1`

	// run query
	XOLog(sqlstr, m.Id)
	_, err = db.Exec(sqlstr, m.Id)
	if err != nil {
		return err
	}

	// set deleted
	m._deleted = true

	return nil
}

// Message represents a row from 'public.message'.
type Message struct {
	Id           int64  `json:"Id"`            // Id
	ToUserId     int    `json:"ToUserId"`      // ToUserId
	RoomKey      string `json:"RoomKey"`       // RoomKey
	MessageKey   string `json:"MessageKey"`    // MessageKey
	FromUserID   int    `json:"FromUserID"`    // FromUserID
	TRIALCOLUMN6 string `json:"TRIAL_COLUMN6"` // TRIAL_COLUMN6
	TRIALCOLUMN7 int64  `json:"TRIAL_COLUMN7"` // TRIAL_COLUMN7

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Message exists in the database.
func (m *Message) Exists() bool {
	return m._exists
}

// Deleted provides information if the Message has been deleted from the database.
func (m *Message) Deleted() bool {
	return m._deleted
}

// Insert inserts the Message to the database.
func (m *Message) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if m._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.message (` +
		`ToUserId, RoomKey, MessageKey, FromUserID, TRIAL_COLUMN6, TRIAL_COLUMN7` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, m.ToUserId, m.RoomKey, m.MessageKey, m.FromUserID, m.TRIALCOLUMN6, m.TRIALCOLUMN7)
	err = db.QueryRow(sqlstr, m.ToUserId, m.RoomKey, m.MessageKey, m.FromUserID, m.TRIALCOLUMN6, m.TRIALCOLUMN7).Scan(&m.Id)
	if err != nil {
		return err
	}

	// set existence
	m._exists = true

	return nil
}

// Update updates the Message in the database.
func (m *Message) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !m._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if m._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.message SET (` +
		`ToUserId, RoomKey, MessageKey, FromUserID, TRIAL_COLUMN6, TRIAL_COLUMN7` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6` +
		`) WHERE Id = $7`

	// run query
	XOLog(sqlstr, m.ToUserId, m.RoomKey, m.MessageKey, m.FromUserID, m.TRIALCOLUMN6, m.TRIALCOLUMN7, m.Id)
	_, err = db.Exec(sqlstr, m.ToUserId, m.RoomKey, m.MessageKey, m.FromUserID, m.TRIALCOLUMN6, m.TRIALCOLUMN7, m.Id)
	return err
}

// Save saves the Message to the database.
func (m *Message) Save(db XODB) error {
	if m.Exists() {
		return m.Update(db)
	}

	return m.Insert(db)
}

// Upsert performs an upsert for Message.
//
// NOTE: PostgreSQL 9.5+ only
func (m *Message) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if m._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.message (` +
		`Id, ToUserId, RoomKey, MessageKey, FromUserID, TRIAL_COLUMN6, TRIAL_COLUMN7` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, ToUserId, RoomKey, MessageKey, FromUserID, TRIAL_COLUMN6, TRIAL_COLUMN7` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.ToUserId, EXCLUDED.RoomKey, EXCLUDED.MessageKey, EXCLUDED.FromUserID, EXCLUDED.TRIAL_COLUMN6, EXCLUDED.TRIAL_COLUMN7` +
		`)`

	// run query
	XOLog(sqlstr, m.Id, m.ToUserId, m.RoomKey, m.MessageKey, m.FromUserID, m.TRIALCOLUMN6, m.TRIALCOLUMN7)
	_, err = db.Exec(sqlstr, m.Id, m.ToUserId, m.RoomKey, m.MessageKey, m.FromUserID, m.TRIALCOLUMN6, m.TRIALCOLUMN7)
	if err != nil {
		return err
	}

	// set existence
	m._exists = true

	return nil
}

// Delete deletes the Message from the database.
func (m *Message) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !m._exists {
		return nil
	}

	// if deleted, bail
	if m._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.message WHERE Id = $1`

	// run query
	XOLog(sqlstr, m.Id)
	_, err = db.Exec(sqlstr, m.Id)
	if err != nil {
		return err
	}

	// set deleted
	m._deleted = true

	return nil
}

// MsgDeletedFromServer represents a row from 'public.msg_deleted_from_server'.
type MsgDeletedFromServer struct {
	Id           int64  `json:"Id"`            // Id
	ToUserId     int    `json:"ToUserId"`      // ToUserId
	MsgKey       string `json:"MsgKey"`        // MsgKey
	PeerUserId   int    `json:"PeerUserId"`    // PeerUserId
	RoomKey      string `json:"RoomKey"`       // RoomKey
	TRIALCOLUMN6 int    `json:"TRIAL_COLUMN6"` // TRIAL_COLUMN6

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the MsgDeletedFromServer exists in the database.
func (mdfs *MsgDeletedFromServer) Exists() bool {
	return mdfs._exists
}

// Deleted provides information if the MsgDeletedFromServer has been deleted from the database.
func (mdfs *MsgDeletedFromServer) Deleted() bool {
	return mdfs._deleted
}

// Insert inserts the MsgDeletedFromServer to the database.
func (mdfs *MsgDeletedFromServer) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if mdfs._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.msg_deleted_from_server (` +
		`ToUserId, MsgKey, PeerUserId, RoomKey, TRIAL_COLUMN6` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, mdfs.ToUserId, mdfs.MsgKey, mdfs.PeerUserId, mdfs.RoomKey, mdfs.TRIALCOLUMN6)
	err = db.QueryRow(sqlstr, mdfs.ToUserId, mdfs.MsgKey, mdfs.PeerUserId, mdfs.RoomKey, mdfs.TRIALCOLUMN6).Scan(&mdfs.Id)
	if err != nil {
		return err
	}

	// set existence
	mdfs._exists = true

	return nil
}

// Update updates the MsgDeletedFromServer in the database.
func (mdfs *MsgDeletedFromServer) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !mdfs._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if mdfs._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.msg_deleted_from_server SET (` +
		`ToUserId, MsgKey, PeerUserId, RoomKey, TRIAL_COLUMN6` +
		`) = ( ` +
		`$1, $2, $3, $4, $5` +
		`) WHERE Id = $6`

	// run query
	XOLog(sqlstr, mdfs.ToUserId, mdfs.MsgKey, mdfs.PeerUserId, mdfs.RoomKey, mdfs.TRIALCOLUMN6, mdfs.Id)
	_, err = db.Exec(sqlstr, mdfs.ToUserId, mdfs.MsgKey, mdfs.PeerUserId, mdfs.RoomKey, mdfs.TRIALCOLUMN6, mdfs.Id)
	return err
}

// Save saves the MsgDeletedFromServer to the database.
func (mdfs *MsgDeletedFromServer) Save(db XODB) error {
	if mdfs.Exists() {
		return mdfs.Update(db)
	}

	return mdfs.Insert(db)
}

// Upsert performs an upsert for MsgDeletedFromServer.
//
// NOTE: PostgreSQL 9.5+ only
func (mdfs *MsgDeletedFromServer) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if mdfs._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.msg_deleted_from_server (` +
		`Id, ToUserId, MsgKey, PeerUserId, RoomKey, TRIAL_COLUMN6` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, ToUserId, MsgKey, PeerUserId, RoomKey, TRIAL_COLUMN6` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.ToUserId, EXCLUDED.MsgKey, EXCLUDED.PeerUserId, EXCLUDED.RoomKey, EXCLUDED.TRIAL_COLUMN6` +
		`)`

	// run query
	XOLog(sqlstr, mdfs.Id, mdfs.ToUserId, mdfs.MsgKey, mdfs.PeerUserId, mdfs.RoomKey, mdfs.TRIALCOLUMN6)
	_, err = db.Exec(sqlstr, mdfs.Id, mdfs.ToUserId, mdfs.MsgKey, mdfs.PeerUserId, mdfs.RoomKey, mdfs.TRIALCOLUMN6)
	if err != nil {
		return err
	}

	// set existence
	mdfs._exists = true

	return nil
}

// Delete deletes the MsgDeletedFromServer from the database.
func (mdfs *MsgDeletedFromServer) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !mdfs._exists {
		return nil
	}

	// if deleted, bail
	if mdfs._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.msg_deleted_from_server WHERE Id = $1`

	// run query
	XOLog(sqlstr, mdfs.Id)
	_, err = db.Exec(sqlstr, mdfs.Id)
	if err != nil {
		return err
	}

	// set deleted
	mdfs._deleted = true

	return nil
}

// MsgReceivedToPeer represents a row from 'public.msg_received_to_peer'.
type MsgReceivedToPeer struct {
	Id           int64  `json:"Id"`            // Id
	ToUserId     int    `json:"ToUserId"`      // ToUserId
	MsgKey       string `json:"MsgKey"`        // MsgKey
	RoomKey      string `json:"RoomKey"`       // RoomKey
	PeerUserId   int    `json:"PeerUserId"`    // PeerUserId
	TRIALCOLUMN6 int    `json:"TRIAL_COLUMN6"` // TRIAL_COLUMN6

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the MsgReceivedToPeer exists in the database.
func (mrtp *MsgReceivedToPeer) Exists() bool {
	return mrtp._exists
}

// Deleted provides information if the MsgReceivedToPeer has been deleted from the database.
func (mrtp *MsgReceivedToPeer) Deleted() bool {
	return mrtp._deleted
}

// Insert inserts the MsgReceivedToPeer to the database.
func (mrtp *MsgReceivedToPeer) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if mrtp._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.msg_received_to_peer (` +
		`ToUserId, MsgKey, RoomKey, PeerUserId, TRIAL_COLUMN6` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, mrtp.ToUserId, mrtp.MsgKey, mrtp.RoomKey, mrtp.PeerUserId, mrtp.TRIALCOLUMN6)
	err = db.QueryRow(sqlstr, mrtp.ToUserId, mrtp.MsgKey, mrtp.RoomKey, mrtp.PeerUserId, mrtp.TRIALCOLUMN6).Scan(&mrtp.Id)
	if err != nil {
		return err
	}

	// set existence
	mrtp._exists = true

	return nil
}

// Update updates the MsgReceivedToPeer in the database.
func (mrtp *MsgReceivedToPeer) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !mrtp._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if mrtp._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.msg_received_to_peer SET (` +
		`ToUserId, MsgKey, RoomKey, PeerUserId, TRIAL_COLUMN6` +
		`) = ( ` +
		`$1, $2, $3, $4, $5` +
		`) WHERE Id = $6`

	// run query
	XOLog(sqlstr, mrtp.ToUserId, mrtp.MsgKey, mrtp.RoomKey, mrtp.PeerUserId, mrtp.TRIALCOLUMN6, mrtp.Id)
	_, err = db.Exec(sqlstr, mrtp.ToUserId, mrtp.MsgKey, mrtp.RoomKey, mrtp.PeerUserId, mrtp.TRIALCOLUMN6, mrtp.Id)
	return err
}

// Save saves the MsgReceivedToPeer to the database.
func (mrtp *MsgReceivedToPeer) Save(db XODB) error {
	if mrtp.Exists() {
		return mrtp.Update(db)
	}

	return mrtp.Insert(db)
}

// Upsert performs an upsert for MsgReceivedToPeer.
//
// NOTE: PostgreSQL 9.5+ only
func (mrtp *MsgReceivedToPeer) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if mrtp._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.msg_received_to_peer (` +
		`Id, ToUserId, MsgKey, RoomKey, PeerUserId, TRIAL_COLUMN6` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, ToUserId, MsgKey, RoomKey, PeerUserId, TRIAL_COLUMN6` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.ToUserId, EXCLUDED.MsgKey, EXCLUDED.RoomKey, EXCLUDED.PeerUserId, EXCLUDED.TRIAL_COLUMN6` +
		`)`

	// run query
	XOLog(sqlstr, mrtp.Id, mrtp.ToUserId, mrtp.MsgKey, mrtp.RoomKey, mrtp.PeerUserId, mrtp.TRIALCOLUMN6)
	_, err = db.Exec(sqlstr, mrtp.Id, mrtp.ToUserId, mrtp.MsgKey, mrtp.RoomKey, mrtp.PeerUserId, mrtp.TRIALCOLUMN6)
	if err != nil {
		return err
	}

	// set existence
	mrtp._exists = true

	return nil
}

// Delete deletes the MsgReceivedToPeer from the database.
func (mrtp *MsgReceivedToPeer) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !mrtp._exists {
		return nil
	}

	// if deleted, bail
	if mrtp._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.msg_received_to_peer WHERE Id = $1`

	// run query
	XOLog(sqlstr, mrtp.Id)
	_, err = db.Exec(sqlstr, mrtp.Id)
	if err != nil {
		return err
	}

	// set deleted
	mrtp._deleted = true

	return nil
}

// MsgSeenByPeer represents a row from 'public.msg_seen_by_peer'.
type MsgSeenByPeer struct {
	Id           int64  `json:"Id"`            // Id
	ToUserId     int    `json:"ToUserId"`      // ToUserId
	MsgKey       string `json:"MsgKey"`        // MsgKey
	RoomKey      string `json:"RoomKey"`       // RoomKey
	PeerUserId   int    `json:"PeerUserId"`    // PeerUserId
	TRIALCOLUMN6 int    `json:"TRIAL_COLUMN6"` // TRIAL_COLUMN6

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the MsgSeenByPeer exists in the database.
func (msbp *MsgSeenByPeer) Exists() bool {
	return msbp._exists
}

// Deleted provides information if the MsgSeenByPeer has been deleted from the database.
func (msbp *MsgSeenByPeer) Deleted() bool {
	return msbp._deleted
}

// Insert inserts the MsgSeenByPeer to the database.
func (msbp *MsgSeenByPeer) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if msbp._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.msg_seen_by_peer (` +
		`ToUserId, MsgKey, RoomKey, PeerUserId, TRIAL_COLUMN6` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, msbp.ToUserId, msbp.MsgKey, msbp.RoomKey, msbp.PeerUserId, msbp.TRIALCOLUMN6)
	err = db.QueryRow(sqlstr, msbp.ToUserId, msbp.MsgKey, msbp.RoomKey, msbp.PeerUserId, msbp.TRIALCOLUMN6).Scan(&msbp.Id)
	if err != nil {
		return err
	}

	// set existence
	msbp._exists = true

	return nil
}

// Update updates the MsgSeenByPeer in the database.
func (msbp *MsgSeenByPeer) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !msbp._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if msbp._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.msg_seen_by_peer SET (` +
		`ToUserId, MsgKey, RoomKey, PeerUserId, TRIAL_COLUMN6` +
		`) = ( ` +
		`$1, $2, $3, $4, $5` +
		`) WHERE Id = $6`

	// run query
	XOLog(sqlstr, msbp.ToUserId, msbp.MsgKey, msbp.RoomKey, msbp.PeerUserId, msbp.TRIALCOLUMN6, msbp.Id)
	_, err = db.Exec(sqlstr, msbp.ToUserId, msbp.MsgKey, msbp.RoomKey, msbp.PeerUserId, msbp.TRIALCOLUMN6, msbp.Id)
	return err
}

// Save saves the MsgSeenByPeer to the database.
func (msbp *MsgSeenByPeer) Save(db XODB) error {
	if msbp.Exists() {
		return msbp.Update(db)
	}

	return msbp.Insert(db)
}

// Upsert performs an upsert for MsgSeenByPeer.
//
// NOTE: PostgreSQL 9.5+ only
func (msbp *MsgSeenByPeer) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if msbp._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.msg_seen_by_peer (` +
		`Id, ToUserId, MsgKey, RoomKey, PeerUserId, TRIAL_COLUMN6` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, ToUserId, MsgKey, RoomKey, PeerUserId, TRIAL_COLUMN6` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.ToUserId, EXCLUDED.MsgKey, EXCLUDED.RoomKey, EXCLUDED.PeerUserId, EXCLUDED.TRIAL_COLUMN6` +
		`)`

	// run query
	XOLog(sqlstr, msbp.Id, msbp.ToUserId, msbp.MsgKey, msbp.RoomKey, msbp.PeerUserId, msbp.TRIALCOLUMN6)
	_, err = db.Exec(sqlstr, msbp.Id, msbp.ToUserId, msbp.MsgKey, msbp.RoomKey, msbp.PeerUserId, msbp.TRIALCOLUMN6)
	if err != nil {
		return err
	}

	// set existence
	msbp._exists = true

	return nil
}

// Delete deletes the MsgSeenByPeer from the database.
func (msbp *MsgSeenByPeer) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !msbp._exists {
		return nil
	}

	// if deleted, bail
	if msbp._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.msg_seen_by_peer WHERE Id = $1`

	// run query
	XOLog(sqlstr, msbp.Id)
	_, err = db.Exec(sqlstr, msbp.Id)
	if err != nil {
		return err
	}

	// set deleted
	msbp._deleted = true

	return nil
}

// Notification represents a row from 'public.notification'.
type Notification struct {
	Id           int `json:"Id"`            // Id
	ForUserId    int `json:"ForUserId"`     // ForUserId
	ActorUserId  int `json:"ActorUserId"`   // ActorUserId
	ActionTypeId int `json:"ActionTypeId"`  // ActionTypeId
	ObjectTypeId int `json:"ObjectTypeId"`  // ObjectTypeId
	TRIALCOLUMN6 int `json:"TRIAL_COLUMN6"` // TRIAL_COLUMN6
	TRIALCOLUMN7 int `json:"TRIAL_COLUMN7"` // TRIAL_COLUMN7
	TRIALCOLUMN8 int `json:"TRIAL_COLUMN8"` // TRIAL_COLUMN8
	TRIALCOLUMN9 int `json:"TRIAL_COLUMN9"` // TRIAL_COLUMN9

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Notification exists in the database.
func (n *Notification) Exists() bool {
	return n._exists
}

// Deleted provides information if the Notification has been deleted from the database.
func (n *Notification) Deleted() bool {
	return n._deleted
}

// Insert inserts the Notification to the database.
func (n *Notification) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if n._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.notification (` +
		`ForUserId, ActorUserId, ActionTypeId, ObjectTypeId, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, n.ForUserId, n.ActorUserId, n.ActionTypeId, n.ObjectTypeId, n.TRIALCOLUMN6, n.TRIALCOLUMN7, n.TRIALCOLUMN8, n.TRIALCOLUMN9)
	err = db.QueryRow(sqlstr, n.ForUserId, n.ActorUserId, n.ActionTypeId, n.ObjectTypeId, n.TRIALCOLUMN6, n.TRIALCOLUMN7, n.TRIALCOLUMN8, n.TRIALCOLUMN9).Scan(&n.Id)
	if err != nil {
		return err
	}

	// set existence
	n._exists = true

	return nil
}

// Update updates the Notification in the database.
func (n *Notification) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !n._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if n._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.notification SET (` +
		`ForUserId, ActorUserId, ActionTypeId, ObjectTypeId, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`) WHERE Id = $9`

	// run query
	XOLog(sqlstr, n.ForUserId, n.ActorUserId, n.ActionTypeId, n.ObjectTypeId, n.TRIALCOLUMN6, n.TRIALCOLUMN7, n.TRIALCOLUMN8, n.TRIALCOLUMN9, n.Id)
	_, err = db.Exec(sqlstr, n.ForUserId, n.ActorUserId, n.ActionTypeId, n.ObjectTypeId, n.TRIALCOLUMN6, n.TRIALCOLUMN7, n.TRIALCOLUMN8, n.TRIALCOLUMN9, n.Id)
	return err
}

// Save saves the Notification to the database.
func (n *Notification) Save(db XODB) error {
	if n.Exists() {
		return n.Update(db)
	}

	return n.Insert(db)
}

// Upsert performs an upsert for Notification.
//
// NOTE: PostgreSQL 9.5+ only
func (n *Notification) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if n._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.notification (` +
		`Id, ForUserId, ActorUserId, ActionTypeId, ObjectTypeId, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, ForUserId, ActorUserId, ActionTypeId, ObjectTypeId, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.ForUserId, EXCLUDED.ActorUserId, EXCLUDED.ActionTypeId, EXCLUDED.ObjectTypeId, EXCLUDED.TRIAL_COLUMN6, EXCLUDED.TRIAL_COLUMN7, EXCLUDED.TRIAL_COLUMN8, EXCLUDED.TRIAL_COLUMN9` +
		`)`

	// run query
	XOLog(sqlstr, n.Id, n.ForUserId, n.ActorUserId, n.ActionTypeId, n.ObjectTypeId, n.TRIALCOLUMN6, n.TRIALCOLUMN7, n.TRIALCOLUMN8, n.TRIALCOLUMN9)
	_, err = db.Exec(sqlstr, n.Id, n.ForUserId, n.ActorUserId, n.ActionTypeId, n.ObjectTypeId, n.TRIALCOLUMN6, n.TRIALCOLUMN7, n.TRIALCOLUMN8, n.TRIALCOLUMN9)
	if err != nil {
		return err
	}

	// set existence
	n._exists = true

	return nil
}

// Delete deletes the Notification from the database.
func (n *Notification) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !n._exists {
		return nil
	}

	// if deleted, bail
	if n._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.notification WHERE Id = $1`

	// run query
	XOLog(sqlstr, n.Id)
	_, err = db.Exec(sqlstr, n.Id)
	if err != nil {
		return err
	}

	// set deleted
	n._deleted = true

	return nil
}

// NotificationRemoved represents a row from 'public.notification_removed'.
type NotificationRemoved struct {
	NotificationId int `json:"NotificationId"` // NotificationId
	ForUserId      int `json:"ForUserId"`      // ForUserId

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the NotificationRemoved exists in the database.
func (nr *NotificationRemoved) Exists() bool {
	return nr._exists
}

// Deleted provides information if the NotificationRemoved has been deleted from the database.
func (nr *NotificationRemoved) Deleted() bool {
	return nr._deleted
}

// Insert inserts the NotificationRemoved to the database.
func (nr *NotificationRemoved) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if nr._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.notification_removed (` +
		`ForUserId` +
		`) VALUES (` +
		`$1` +
		`) RETURNING NotificationId`

	// run query
	XOLog(sqlstr, nr.ForUserId)
	err = db.QueryRow(sqlstr, nr.ForUserId).Scan(&nr.NotificationId)
	if err != nil {
		return err
	}

	// set existence
	nr._exists = true

	return nil
}

// Update updates the NotificationRemoved in the database.
func (nr *NotificationRemoved) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !nr._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if nr._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.notification_removed SET (` +
		`ForUserId` +
		`) = ( ` +
		`$1` +
		`) WHERE NotificationId = $2`

	// run query
	XOLog(sqlstr, nr.ForUserId, nr.NotificationId)
	_, err = db.Exec(sqlstr, nr.ForUserId, nr.NotificationId)
	return err
}

// Save saves the NotificationRemoved to the database.
func (nr *NotificationRemoved) Save(db XODB) error {
	if nr.Exists() {
		return nr.Update(db)
	}

	return nr.Insert(db)
}

// Upsert performs an upsert for NotificationRemoved.
//
// NOTE: PostgreSQL 9.5+ only
func (nr *NotificationRemoved) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if nr._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.notification_removed (` +
		`NotificationId, ForUserId` +
		`) VALUES (` +
		`$1, $2` +
		`) ON CONFLICT (NotificationId) DO UPDATE SET (` +
		`NotificationId, ForUserId` +
		`) = (` +
		`EXCLUDED.NotificationId, EXCLUDED.ForUserId` +
		`)`

	// run query
	XOLog(sqlstr, nr.NotificationId, nr.ForUserId)
	_, err = db.Exec(sqlstr, nr.NotificationId, nr.ForUserId)
	if err != nil {
		return err
	}

	// set existence
	nr._exists = true

	return nil
}

// Delete deletes the NotificationRemoved from the database.
func (nr *NotificationRemoved) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !nr._exists {
		return nil
	}

	// if deleted, bail
	if nr._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.notification_removed WHERE NotificationId = $1`

	// run query
	XOLog(sqlstr, nr.NotificationId)
	_, err = db.Exec(sqlstr, nr.NotificationId)
	if err != nil {
		return err
	}

	// set deleted
	nr._deleted = true

	return nil
}

// PhoneContact represents a row from 'public.phone_contacts'.
type PhoneContact struct {
	Id                    int    `json:"Id"`                    // Id
	PhoneDisplayName      string `json:"PhoneDisplayName"`      // PhoneDisplayName
	PhoneFamilyName       string `json:"PhoneFamilyName"`       // PhoneFamilyName
	PhoneNumber           string `json:"PhoneNumber"`           // PhoneNumber
	PhoneNormalizedNumber string `json:"PhoneNormalizedNumber"` // PhoneNormalizedNumber
	TRIALCOLUMN6          int    `json:"TRIAL_COLUMN6"`         // TRIAL_COLUMN6
	TRIALCOLUMN7          int    `json:"TRIAL_COLUMN7"`         // TRIAL_COLUMN7
	TRIALCOLUMN8          int    `json:"TRIAL_COLUMN8"`         // TRIAL_COLUMN8
	TRIALCOLUMN9          int    `json:"TRIAL_COLUMN9"`         // TRIAL_COLUMN9
	TRIALCOLUMN10         int    `json:"TRIAL_COLUMN10"`        // TRIAL_COLUMN10

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the PhoneContact exists in the database.
func (pc *PhoneContact) Exists() bool {
	return pc._exists
}

// Deleted provides information if the PhoneContact has been deleted from the database.
func (pc *PhoneContact) Deleted() bool {
	return pc._deleted
}

// Insert inserts the PhoneContact to the database.
func (pc *PhoneContact) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if pc._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.phone_contacts (` +
		`PhoneDisplayName, PhoneFamilyName, PhoneNumber, PhoneNormalizedNumber, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, pc.PhoneDisplayName, pc.PhoneFamilyName, pc.PhoneNumber, pc.PhoneNormalizedNumber, pc.TRIALCOLUMN6, pc.TRIALCOLUMN7, pc.TRIALCOLUMN8, pc.TRIALCOLUMN9, pc.TRIALCOLUMN10)
	err = db.QueryRow(sqlstr, pc.PhoneDisplayName, pc.PhoneFamilyName, pc.PhoneNumber, pc.PhoneNormalizedNumber, pc.TRIALCOLUMN6, pc.TRIALCOLUMN7, pc.TRIALCOLUMN8, pc.TRIALCOLUMN9, pc.TRIALCOLUMN10).Scan(&pc.Id)
	if err != nil {
		return err
	}

	// set existence
	pc._exists = true

	return nil
}

// Update updates the PhoneContact in the database.
func (pc *PhoneContact) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !pc._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if pc._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.phone_contacts SET (` +
		`PhoneDisplayName, PhoneFamilyName, PhoneNumber, PhoneNormalizedNumber, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`) WHERE Id = $10`

	// run query
	XOLog(sqlstr, pc.PhoneDisplayName, pc.PhoneFamilyName, pc.PhoneNumber, pc.PhoneNormalizedNumber, pc.TRIALCOLUMN6, pc.TRIALCOLUMN7, pc.TRIALCOLUMN8, pc.TRIALCOLUMN9, pc.TRIALCOLUMN10, pc.Id)
	_, err = db.Exec(sqlstr, pc.PhoneDisplayName, pc.PhoneFamilyName, pc.PhoneNumber, pc.PhoneNormalizedNumber, pc.TRIALCOLUMN6, pc.TRIALCOLUMN7, pc.TRIALCOLUMN8, pc.TRIALCOLUMN9, pc.TRIALCOLUMN10, pc.Id)
	return err
}

// Save saves the PhoneContact to the database.
func (pc *PhoneContact) Save(db XODB) error {
	if pc.Exists() {
		return pc.Update(db)
	}

	return pc.Insert(db)
}

// Upsert performs an upsert for PhoneContact.
//
// NOTE: PostgreSQL 9.5+ only
func (pc *PhoneContact) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if pc._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.phone_contacts (` +
		`Id, PhoneDisplayName, PhoneFamilyName, PhoneNumber, PhoneNormalizedNumber, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, PhoneDisplayName, PhoneFamilyName, PhoneNumber, PhoneNormalizedNumber, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.PhoneDisplayName, EXCLUDED.PhoneFamilyName, EXCLUDED.PhoneNumber, EXCLUDED.PhoneNormalizedNumber, EXCLUDED.TRIAL_COLUMN6, EXCLUDED.TRIAL_COLUMN7, EXCLUDED.TRIAL_COLUMN8, EXCLUDED.TRIAL_COLUMN9, EXCLUDED.TRIAL_COLUMN10` +
		`)`

	// run query
	XOLog(sqlstr, pc.Id, pc.PhoneDisplayName, pc.PhoneFamilyName, pc.PhoneNumber, pc.PhoneNormalizedNumber, pc.TRIALCOLUMN6, pc.TRIALCOLUMN7, pc.TRIALCOLUMN8, pc.TRIALCOLUMN9, pc.TRIALCOLUMN10)
	_, err = db.Exec(sqlstr, pc.Id, pc.PhoneDisplayName, pc.PhoneFamilyName, pc.PhoneNumber, pc.PhoneNormalizedNumber, pc.TRIALCOLUMN6, pc.TRIALCOLUMN7, pc.TRIALCOLUMN8, pc.TRIALCOLUMN9, pc.TRIALCOLUMN10)
	if err != nil {
		return err
	}

	// set existence
	pc._exists = true

	return nil
}

// Delete deletes the PhoneContact from the database.
func (pc *PhoneContact) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !pc._exists {
		return nil
	}

	// if deleted, bail
	if pc._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.phone_contacts WHERE Id = $1`

	// run query
	XOLog(sqlstr, pc.Id)
	_, err = db.Exec(sqlstr, pc.Id)
	if err != nil {
		return err
	}

	// set deleted
	pc._deleted = true

	return nil
}

// Post represents a row from 'public.post'.
type Post struct {
	Id            int    `json:"Id"`             // Id
	UserId        int    `json:"UserId"`         // UserId
	TypeId        int    `json:"TypeId"`         // TypeId
	Text          string `json:"Text"`           // Text
	FormatedText  string `json:"FormatedText"`   // FormatedText
	TRIALCOLUMN6  string `json:"TRIAL_COLUMN6"`  // TRIAL_COLUMN6
	TRIALCOLUMN7  int    `json:"TRIAL_COLUMN7"`  // TRIAL_COLUMN7
	TRIALCOLUMN8  int    `json:"TRIAL_COLUMN8"`  // TRIAL_COLUMN8
	TRIALCOLUMN9  int    `json:"TRIAL_COLUMN9"`  // TRIAL_COLUMN9
	TRIALCOLUMN10 int    `json:"TRIAL_COLUMN10"` // TRIAL_COLUMN10
	TRIALCOLUMN11 int    `json:"TRIAL_COLUMN11"` // TRIAL_COLUMN11
	TRIALCOLUMN12 int    `json:"TRIAL_COLUMN12"` // TRIAL_COLUMN12
	TRIALCOLUMN13 int    `json:"TRIAL_COLUMN13"` // TRIAL_COLUMN13
	TRIALCOLUMN14 int    `json:"TRIAL_COLUMN14"` // TRIAL_COLUMN14

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Post exists in the database.
func (p *Post) Exists() bool {
	return p._exists
}

// Deleted provides information if the Post has been deleted from the database.
func (p *Post) Deleted() bool {
	return p._deleted
}

// Insert inserts the Post to the database.
func (p *Post) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if p._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.post (` +
		`UserId, TypeId, Text, FormatedText, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10, TRIAL_COLUMN11, TRIAL_COLUMN12, TRIAL_COLUMN13, TRIAL_COLUMN14` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, p.UserId, p.TypeId, p.Text, p.FormatedText, p.TRIALCOLUMN6, p.TRIALCOLUMN7, p.TRIALCOLUMN8, p.TRIALCOLUMN9, p.TRIALCOLUMN10, p.TRIALCOLUMN11, p.TRIALCOLUMN12, p.TRIALCOLUMN13, p.TRIALCOLUMN14)
	err = db.QueryRow(sqlstr, p.UserId, p.TypeId, p.Text, p.FormatedText, p.TRIALCOLUMN6, p.TRIALCOLUMN7, p.TRIALCOLUMN8, p.TRIALCOLUMN9, p.TRIALCOLUMN10, p.TRIALCOLUMN11, p.TRIALCOLUMN12, p.TRIALCOLUMN13, p.TRIALCOLUMN14).Scan(&p.Id)
	if err != nil {
		return err
	}

	// set existence
	p._exists = true

	return nil
}

// Update updates the Post in the database.
func (p *Post) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !p._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if p._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.post SET (` +
		`UserId, TypeId, Text, FormatedText, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10, TRIAL_COLUMN11, TRIAL_COLUMN12, TRIAL_COLUMN13, TRIAL_COLUMN14` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13` +
		`) WHERE Id = $14`

	// run query
	XOLog(sqlstr, p.UserId, p.TypeId, p.Text, p.FormatedText, p.TRIALCOLUMN6, p.TRIALCOLUMN7, p.TRIALCOLUMN8, p.TRIALCOLUMN9, p.TRIALCOLUMN10, p.TRIALCOLUMN11, p.TRIALCOLUMN12, p.TRIALCOLUMN13, p.TRIALCOLUMN14, p.Id)
	_, err = db.Exec(sqlstr, p.UserId, p.TypeId, p.Text, p.FormatedText, p.TRIALCOLUMN6, p.TRIALCOLUMN7, p.TRIALCOLUMN8, p.TRIALCOLUMN9, p.TRIALCOLUMN10, p.TRIALCOLUMN11, p.TRIALCOLUMN12, p.TRIALCOLUMN13, p.TRIALCOLUMN14, p.Id)
	return err
}

// Save saves the Post to the database.
func (p *Post) Save(db XODB) error {
	if p.Exists() {
		return p.Update(db)
	}

	return p.Insert(db)
}

// Upsert performs an upsert for Post.
//
// NOTE: PostgreSQL 9.5+ only
func (p *Post) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if p._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.post (` +
		`Id, UserId, TypeId, Text, FormatedText, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10, TRIAL_COLUMN11, TRIAL_COLUMN12, TRIAL_COLUMN13, TRIAL_COLUMN14` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, UserId, TypeId, Text, FormatedText, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10, TRIAL_COLUMN11, TRIAL_COLUMN12, TRIAL_COLUMN13, TRIAL_COLUMN14` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.UserId, EXCLUDED.TypeId, EXCLUDED.Text, EXCLUDED.FormatedText, EXCLUDED.TRIAL_COLUMN6, EXCLUDED.TRIAL_COLUMN7, EXCLUDED.TRIAL_COLUMN8, EXCLUDED.TRIAL_COLUMN9, EXCLUDED.TRIAL_COLUMN10, EXCLUDED.TRIAL_COLUMN11, EXCLUDED.TRIAL_COLUMN12, EXCLUDED.TRIAL_COLUMN13, EXCLUDED.TRIAL_COLUMN14` +
		`)`

	// run query
	XOLog(sqlstr, p.Id, p.UserId, p.TypeId, p.Text, p.FormatedText, p.TRIALCOLUMN6, p.TRIALCOLUMN7, p.TRIALCOLUMN8, p.TRIALCOLUMN9, p.TRIALCOLUMN10, p.TRIALCOLUMN11, p.TRIALCOLUMN12, p.TRIALCOLUMN13, p.TRIALCOLUMN14)
	_, err = db.Exec(sqlstr, p.Id, p.UserId, p.TypeId, p.Text, p.FormatedText, p.TRIALCOLUMN6, p.TRIALCOLUMN7, p.TRIALCOLUMN8, p.TRIALCOLUMN9, p.TRIALCOLUMN10, p.TRIALCOLUMN11, p.TRIALCOLUMN12, p.TRIALCOLUMN13, p.TRIALCOLUMN14)
	if err != nil {
		return err
	}

	// set existence
	p._exists = true

	return nil
}

// Delete deletes the Post from the database.
func (p *Post) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !p._exists {
		return nil
	}

	// if deleted, bail
	if p._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.post WHERE Id = $1`

	// run query
	XOLog(sqlstr, p.Id)
	_, err = db.Exec(sqlstr, p.Id)
	if err != nil {
		return err
	}

	// set deleted
	p._deleted = true

	return nil
}

// RecommendUser represents a row from 'public.recommend_user'.
type RecommendUser struct {
	Id          int     `json:"Id"`          // Id
	UserId      int     `json:"UserId"`      // UserId
	TargetId    int     `json:"TargetId"`    // TargetId
	Weight      float64 `json:"Weight"`      // Weight
	CreatedTime int     `json:"CreatedTime"` // CreatedTime

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the RecommendUser exists in the database.
func (ru *RecommendUser) Exists() bool {
	return ru._exists
}

// Deleted provides information if the RecommendUser has been deleted from the database.
func (ru *RecommendUser) Deleted() bool {
	return ru._deleted
}

// Insert inserts the RecommendUser to the database.
func (ru *RecommendUser) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if ru._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.recommend_user (` +
		`UserId, TargetId, Weight, CreatedTime` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, ru.UserId, ru.TargetId, ru.Weight, ru.CreatedTime)
	err = db.QueryRow(sqlstr, ru.UserId, ru.TargetId, ru.Weight, ru.CreatedTime).Scan(&ru.Id)
	if err != nil {
		return err
	}

	// set existence
	ru._exists = true

	return nil
}

// Update updates the RecommendUser in the database.
func (ru *RecommendUser) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !ru._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if ru._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.recommend_user SET (` +
		`UserId, TargetId, Weight, CreatedTime` +
		`) = ( ` +
		`$1, $2, $3, $4` +
		`) WHERE Id = $5`

	// run query
	XOLog(sqlstr, ru.UserId, ru.TargetId, ru.Weight, ru.CreatedTime, ru.Id)
	_, err = db.Exec(sqlstr, ru.UserId, ru.TargetId, ru.Weight, ru.CreatedTime, ru.Id)
	return err
}

// Save saves the RecommendUser to the database.
func (ru *RecommendUser) Save(db XODB) error {
	if ru.Exists() {
		return ru.Update(db)
	}

	return ru.Insert(db)
}

// Upsert performs an upsert for RecommendUser.
//
// NOTE: PostgreSQL 9.5+ only
func (ru *RecommendUser) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if ru._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.recommend_user (` +
		`Id, UserId, TargetId, Weight, CreatedTime` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, UserId, TargetId, Weight, CreatedTime` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.UserId, EXCLUDED.TargetId, EXCLUDED.Weight, EXCLUDED.CreatedTime` +
		`)`

	// run query
	XOLog(sqlstr, ru.Id, ru.UserId, ru.TargetId, ru.Weight, ru.CreatedTime)
	_, err = db.Exec(sqlstr, ru.Id, ru.UserId, ru.TargetId, ru.Weight, ru.CreatedTime)
	if err != nil {
		return err
	}

	// set existence
	ru._exists = true

	return nil
}

// Delete deletes the RecommendUser from the database.
func (ru *RecommendUser) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !ru._exists {
		return nil
	}

	// if deleted, bail
	if ru._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.recommend_user WHERE Id = $1`

	// run query
	XOLog(sqlstr, ru.Id)
	_, err = db.Exec(sqlstr, ru.Id)
	if err != nil {
		return err
	}

	// set deleted
	ru._deleted = true

	return nil
}

// SearchClicked represents a row from 'public.search_clicked'.
type SearchClicked struct {
	Id           int64  `json:"Id"`            // Id
	Query        string `json:"Query"`         // Query
	ClickType    int    `json:"ClickType"`     // ClickType
	TargetId     int    `json:"TargetId"`      // TargetId
	UserId       int    `json:"UserId"`        // UserId
	TRIALCOLUMN6 int    `json:"TRIAL_COLUMN6"` // TRIAL_COLUMN6

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the SearchClicked exists in the database.
func (sc *SearchClicked) Exists() bool {
	return sc._exists
}

// Deleted provides information if the SearchClicked has been deleted from the database.
func (sc *SearchClicked) Deleted() bool {
	return sc._deleted
}

// Insert inserts the SearchClicked to the database.
func (sc *SearchClicked) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if sc._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.search_clicked (` +
		`Query, ClickType, TargetId, UserId, TRIAL_COLUMN6` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, sc.Query, sc.ClickType, sc.TargetId, sc.UserId, sc.TRIALCOLUMN6)
	err = db.QueryRow(sqlstr, sc.Query, sc.ClickType, sc.TargetId, sc.UserId, sc.TRIALCOLUMN6).Scan(&sc.Id)
	if err != nil {
		return err
	}

	// set existence
	sc._exists = true

	return nil
}

// Update updates the SearchClicked in the database.
func (sc *SearchClicked) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !sc._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if sc._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.search_clicked SET (` +
		`Query, ClickType, TargetId, UserId, TRIAL_COLUMN6` +
		`) = ( ` +
		`$1, $2, $3, $4, $5` +
		`) WHERE Id = $6`

	// run query
	XOLog(sqlstr, sc.Query, sc.ClickType, sc.TargetId, sc.UserId, sc.TRIALCOLUMN6, sc.Id)
	_, err = db.Exec(sqlstr, sc.Query, sc.ClickType, sc.TargetId, sc.UserId, sc.TRIALCOLUMN6, sc.Id)
	return err
}

// Save saves the SearchClicked to the database.
func (sc *SearchClicked) Save(db XODB) error {
	if sc.Exists() {
		return sc.Update(db)
	}

	return sc.Insert(db)
}

// Upsert performs an upsert for SearchClicked.
//
// NOTE: PostgreSQL 9.5+ only
func (sc *SearchClicked) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if sc._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.search_clicked (` +
		`Id, Query, ClickType, TargetId, UserId, TRIAL_COLUMN6` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, Query, ClickType, TargetId, UserId, TRIAL_COLUMN6` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.Query, EXCLUDED.ClickType, EXCLUDED.TargetId, EXCLUDED.UserId, EXCLUDED.TRIAL_COLUMN6` +
		`)`

	// run query
	XOLog(sqlstr, sc.Id, sc.Query, sc.ClickType, sc.TargetId, sc.UserId, sc.TRIALCOLUMN6)
	_, err = db.Exec(sqlstr, sc.Id, sc.Query, sc.ClickType, sc.TargetId, sc.UserId, sc.TRIALCOLUMN6)
	if err != nil {
		return err
	}

	// set existence
	sc._exists = true

	return nil
}

// Delete deletes the SearchClicked from the database.
func (sc *SearchClicked) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !sc._exists {
		return nil
	}

	// if deleted, bail
	if sc._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.search_clicked WHERE Id = $1`

	// run query
	XOLog(sqlstr, sc.Id)
	_, err = db.Exec(sqlstr, sc.Id)
	if err != nil {
		return err
	}

	// set deleted
	sc._deleted = true

	return nil
}

// Session represents a row from 'public.session'.
type Session struct {
	Id            int    `json:"Id"`             // Id
	UserId        int    `json:"UserId"`         // UserId
	SessionUuid   string `json:"SessionUuid"`    // SessionUuid
	ClientUuid    string `json:"ClientUuid"`     // ClientUuid
	DeviceUuid    string `json:"DeviceUuid"`     // DeviceUuid
	TRIALCOLUMN6  int    `json:"TRIAL_COLUMN6"`  // TRIAL_COLUMN6
	TRIALCOLUMN7  string `json:"TRIAL_COLUMN7"`  // TRIAL_COLUMN7
	TRIALCOLUMN8  string `json:"TRIAL_COLUMN8"`  // TRIAL_COLUMN8
	TRIALCOLUMN9  string `json:"TRIAL_COLUMN9"`  // TRIAL_COLUMN9
	TRIALCOLUMN10 int    `json:"TRIAL_COLUMN10"` // TRIAL_COLUMN10

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Session exists in the database.
func (s *Session) Exists() bool {
	return s._exists
}

// Deleted provides information if the Session has been deleted from the database.
func (s *Session) Deleted() bool {
	return s._deleted
}

// Insert inserts the Session to the database.
func (s *Session) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if s._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.session (` +
		`UserId, SessionUuid, ClientUuid, DeviceUuid, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, s.UserId, s.SessionUuid, s.ClientUuid, s.DeviceUuid, s.TRIALCOLUMN6, s.TRIALCOLUMN7, s.TRIALCOLUMN8, s.TRIALCOLUMN9, s.TRIALCOLUMN10)
	err = db.QueryRow(sqlstr, s.UserId, s.SessionUuid, s.ClientUuid, s.DeviceUuid, s.TRIALCOLUMN6, s.TRIALCOLUMN7, s.TRIALCOLUMN8, s.TRIALCOLUMN9, s.TRIALCOLUMN10).Scan(&s.Id)
	if err != nil {
		return err
	}

	// set existence
	s._exists = true

	return nil
}

// Update updates the Session in the database.
func (s *Session) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !s._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if s._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.session SET (` +
		`UserId, SessionUuid, ClientUuid, DeviceUuid, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`) WHERE Id = $10`

	// run query
	XOLog(sqlstr, s.UserId, s.SessionUuid, s.ClientUuid, s.DeviceUuid, s.TRIALCOLUMN6, s.TRIALCOLUMN7, s.TRIALCOLUMN8, s.TRIALCOLUMN9, s.TRIALCOLUMN10, s.Id)
	_, err = db.Exec(sqlstr, s.UserId, s.SessionUuid, s.ClientUuid, s.DeviceUuid, s.TRIALCOLUMN6, s.TRIALCOLUMN7, s.TRIALCOLUMN8, s.TRIALCOLUMN9, s.TRIALCOLUMN10, s.Id)
	return err
}

// Save saves the Session to the database.
func (s *Session) Save(db XODB) error {
	if s.Exists() {
		return s.Update(db)
	}

	return s.Insert(db)
}

// Upsert performs an upsert for Session.
//
// NOTE: PostgreSQL 9.5+ only
func (s *Session) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if s._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.session (` +
		`Id, UserId, SessionUuid, ClientUuid, DeviceUuid, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, UserId, SessionUuid, ClientUuid, DeviceUuid, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.UserId, EXCLUDED.SessionUuid, EXCLUDED.ClientUuid, EXCLUDED.DeviceUuid, EXCLUDED.TRIAL_COLUMN6, EXCLUDED.TRIAL_COLUMN7, EXCLUDED.TRIAL_COLUMN8, EXCLUDED.TRIAL_COLUMN9, EXCLUDED.TRIAL_COLUMN10` +
		`)`

	// run query
	XOLog(sqlstr, s.Id, s.UserId, s.SessionUuid, s.ClientUuid, s.DeviceUuid, s.TRIALCOLUMN6, s.TRIALCOLUMN7, s.TRIALCOLUMN8, s.TRIALCOLUMN9, s.TRIALCOLUMN10)
	_, err = db.Exec(sqlstr, s.Id, s.UserId, s.SessionUuid, s.ClientUuid, s.DeviceUuid, s.TRIALCOLUMN6, s.TRIALCOLUMN7, s.TRIALCOLUMN8, s.TRIALCOLUMN9, s.TRIALCOLUMN10)
	if err != nil {
		return err
	}

	// set existence
	s._exists = true

	return nil
}

// Delete deletes the Session from the database.
func (s *Session) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !s._exists {
		return nil
	}

	// if deleted, bail
	if s._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.session WHERE Id = $1`

	// run query
	XOLog(sqlstr, s.Id)
	_, err = db.Exec(sqlstr, s.Id)
	if err != nil {
		return err
	}

	// set deleted
	s._deleted = true

	return nil
}

// Tag represents a row from 'public.tags'.
type Tag struct {
	Id          int    `json:"Id"`          // Id
	Name        string `json:"Name"`        // Name
	Count       int    `json:"Count"`       // Count
	IsBlocked   int    `json:"IsBlocked"`   // IsBlocked
	CreatedTime int    `json:"CreatedTime"` // CreatedTime

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Tag exists in the database.
func (t *Tag) Exists() bool {
	return t._exists
}

// Deleted provides information if the Tag has been deleted from the database.
func (t *Tag) Deleted() bool {
	return t._deleted
}

// Insert inserts the Tag to the database.
func (t *Tag) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if t._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.tags (` +
		`Name, Count, IsBlocked, CreatedTime` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, t.Name, t.Count, t.IsBlocked, t.CreatedTime)
	err = db.QueryRow(sqlstr, t.Name, t.Count, t.IsBlocked, t.CreatedTime).Scan(&t.Id)
	if err != nil {
		return err
	}

	// set existence
	t._exists = true

	return nil
}

// Update updates the Tag in the database.
func (t *Tag) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !t._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if t._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.tags SET (` +
		`Name, Count, IsBlocked, CreatedTime` +
		`) = ( ` +
		`$1, $2, $3, $4` +
		`) WHERE Id = $5`

	// run query
	XOLog(sqlstr, t.Name, t.Count, t.IsBlocked, t.CreatedTime, t.Id)
	_, err = db.Exec(sqlstr, t.Name, t.Count, t.IsBlocked, t.CreatedTime, t.Id)
	return err
}

// Save saves the Tag to the database.
func (t *Tag) Save(db XODB) error {
	if t.Exists() {
		return t.Update(db)
	}

	return t.Insert(db)
}

// Upsert performs an upsert for Tag.
//
// NOTE: PostgreSQL 9.5+ only
func (t *Tag) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if t._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.tags (` +
		`Id, Name, Count, IsBlocked, CreatedTime` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, Name, Count, IsBlocked, CreatedTime` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.Name, EXCLUDED.Count, EXCLUDED.IsBlocked, EXCLUDED.CreatedTime` +
		`)`

	// run query
	XOLog(sqlstr, t.Id, t.Name, t.Count, t.IsBlocked, t.CreatedTime)
	_, err = db.Exec(sqlstr, t.Id, t.Name, t.Count, t.IsBlocked, t.CreatedTime)
	if err != nil {
		return err
	}

	// set existence
	t._exists = true

	return nil
}

// Delete deletes the Tag from the database.
func (t *Tag) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !t._exists {
		return nil
	}

	// if deleted, bail
	if t._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.tags WHERE Id = $1`

	// run query
	XOLog(sqlstr, t.Id)
	_, err = db.Exec(sqlstr, t.Id)
	if err != nil {
		return err
	}

	// set deleted
	t._deleted = true

	return nil
}

// TagsPost represents a row from 'public.tags_posts'.
type TagsPost struct {
	Id          int `json:"Id"`          // Id
	TagId       int `json:"TagId"`       // TagId
	PostId      int `json:"PostId"`      // PostId
	TypeId      int `json:"TypeId"`      // TypeId
	CreatedTime int `json:"CreatedTime"` // CreatedTime

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the TagsPost exists in the database.
func (tp *TagsPost) Exists() bool {
	return tp._exists
}

// Deleted provides information if the TagsPost has been deleted from the database.
func (tp *TagsPost) Deleted() bool {
	return tp._deleted
}

// Insert inserts the TagsPost to the database.
func (tp *TagsPost) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if tp._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.tags_posts (` +
		`TagId, PostId, TypeId, CreatedTime` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, tp.TagId, tp.PostId, tp.TypeId, tp.CreatedTime)
	err = db.QueryRow(sqlstr, tp.TagId, tp.PostId, tp.TypeId, tp.CreatedTime).Scan(&tp.Id)
	if err != nil {
		return err
	}

	// set existence
	tp._exists = true

	return nil
}

// Update updates the TagsPost in the database.
func (tp *TagsPost) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !tp._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if tp._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.tags_posts SET (` +
		`TagId, PostId, TypeId, CreatedTime` +
		`) = ( ` +
		`$1, $2, $3, $4` +
		`) WHERE Id = $5`

	// run query
	XOLog(sqlstr, tp.TagId, tp.PostId, tp.TypeId, tp.CreatedTime, tp.Id)
	_, err = db.Exec(sqlstr, tp.TagId, tp.PostId, tp.TypeId, tp.CreatedTime, tp.Id)
	return err
}

// Save saves the TagsPost to the database.
func (tp *TagsPost) Save(db XODB) error {
	if tp.Exists() {
		return tp.Update(db)
	}

	return tp.Insert(db)
}

// Upsert performs an upsert for TagsPost.
//
// NOTE: PostgreSQL 9.5+ only
func (tp *TagsPost) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if tp._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.tags_posts (` +
		`Id, TagId, PostId, TypeId, CreatedTime` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, TagId, PostId, TypeId, CreatedTime` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.TagId, EXCLUDED.PostId, EXCLUDED.TypeId, EXCLUDED.CreatedTime` +
		`)`

	// run query
	XOLog(sqlstr, tp.Id, tp.TagId, tp.PostId, tp.TypeId, tp.CreatedTime)
	_, err = db.Exec(sqlstr, tp.Id, tp.TagId, tp.PostId, tp.TypeId, tp.CreatedTime)
	if err != nil {
		return err
	}

	// set existence
	tp._exists = true

	return nil
}

// Delete deletes the TagsPost from the database.
func (tp *TagsPost) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !tp._exists {
		return nil
	}

	// if deleted, bail
	if tp._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.tags_posts WHERE Id = $1`

	// run query
	XOLog(sqlstr, tp.Id)
	_, err = db.Exec(sqlstr, tp.Id)
	if err != nil {
		return err
	}

	// set deleted
	tp._deleted = true

	return nil
}

// User represents a row from 'public.user'.
type User struct {
	Id            int    `json:"Id"`             // Id
	UserName      string `json:"UserName"`       // UserName
	FirstName     string `json:"FirstName"`      // FirstName
	LastName      string `json:"LastName"`       // LastName
	About         string `json:"About"`          // About
	TRIALCOLUMN6  string `json:"TRIAL_COLUMN6"`  // TRIAL_COLUMN6
	TRIALCOLUMN7  string `json:"TRIAL_COLUMN7"`  // TRIAL_COLUMN7
	TRIALCOLUMN8  int16  `json:"TRIAL_COLUMN8"`  // TRIAL_COLUMN8
	TRIALCOLUMN9  string `json:"TRIAL_COLUMN9"`  // TRIAL_COLUMN9
	TRIALCOLUMN10 string `json:"TRIAL_COLUMN10"` // TRIAL_COLUMN10
	TRIALCOLUMN11 int    `json:"TRIAL_COLUMN11"` // TRIAL_COLUMN11
	TRIALCOLUMN12 string `json:"TRIAL_COLUMN12"` // TRIAL_COLUMN12
	TRIALCOLUMN13 string `json:"TRIAL_COLUMN13"` // TRIAL_COLUMN13
	TRIALCOLUMN14 int    `json:"TRIAL_COLUMN14"` // TRIAL_COLUMN14
	TRIALCOLUMN15 int    `json:"TRIAL_COLUMN15"` // TRIAL_COLUMN15
	TRIALCOLUMN16 int    `json:"TRIAL_COLUMN16"` // TRIAL_COLUMN16
	TRIALCOLUMN17 int    `json:"TRIAL_COLUMN17"` // TRIAL_COLUMN17
	TRIALCOLUMN18 int    `json:"TRIAL_COLUMN18"` // TRIAL_COLUMN18
	TRIALCOLUMN19 int    `json:"TRIAL_COLUMN19"` // TRIAL_COLUMN19
	TRIALCOLUMN20 int    `json:"TRIAL_COLUMN20"` // TRIAL_COLUMN20
	TRIALCOLUMN21 int    `json:"TRIAL_COLUMN21"` // TRIAL_COLUMN21
	TRIALCOLUMN22 int    `json:"TRIAL_COLUMN22"` // TRIAL_COLUMN22
	TRIALCOLUMN23 int    `json:"TRIAL_COLUMN23"` // TRIAL_COLUMN23
	TRIALCOLUMN24 int    `json:"TRIAL_COLUMN24"` // TRIAL_COLUMN24
	TRIALCOLUMN25 string `json:"TRIAL_COLUMN25"` // TRIAL_COLUMN25
	TRIALCOLUMN26 string `json:"TRIAL_COLUMN26"` // TRIAL_COLUMN26
	TRIALCOLUMN27 string `json:"TRIAL_COLUMN27"` // TRIAL_COLUMN27
	TRIALCOLUMN28 string `json:"TRIAL_COLUMN28"` // TRIAL_COLUMN28
	TRIALCOLUMN29 int    `json:"TRIAL_COLUMN29"` // TRIAL_COLUMN29
	TRIALCOLUMN30 int    `json:"TRIAL_COLUMN30"` // TRIAL_COLUMN30
	TRIALCOLUMN31 int    `json:"TRIAL_COLUMN31"` // TRIAL_COLUMN31
	TRIALCOLUMN32 string `json:"TRIAL_COLUMN32"` // TRIAL_COLUMN32

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the User exists in the database.
func (u *User) Exists() bool {
	return u._exists
}

// Deleted provides information if the User has been deleted from the database.
func (u *User) Deleted() bool {
	return u._deleted
}

// Insert inserts the User to the database.
func (u *User) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if u._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.user (` +
		`UserName, FirstName, LastName, About, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10, TRIAL_COLUMN11, TRIAL_COLUMN12, TRIAL_COLUMN13, TRIAL_COLUMN14, TRIAL_COLUMN15, TRIAL_COLUMN16, TRIAL_COLUMN17, TRIAL_COLUMN18, TRIAL_COLUMN19, TRIAL_COLUMN20, TRIAL_COLUMN21, TRIAL_COLUMN22, TRIAL_COLUMN23, TRIAL_COLUMN24, TRIAL_COLUMN25, TRIAL_COLUMN26, TRIAL_COLUMN27, TRIAL_COLUMN28, TRIAL_COLUMN29, TRIAL_COLUMN30, TRIAL_COLUMN31, TRIAL_COLUMN32` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31` +
		`) RETURNING Id`

	// run query
	XOLog(sqlstr, u.UserName, u.FirstName, u.LastName, u.About, u.TRIALCOLUMN6, u.TRIALCOLUMN7, u.TRIALCOLUMN8, u.TRIALCOLUMN9, u.TRIALCOLUMN10, u.TRIALCOLUMN11, u.TRIALCOLUMN12, u.TRIALCOLUMN13, u.TRIALCOLUMN14, u.TRIALCOLUMN15, u.TRIALCOLUMN16, u.TRIALCOLUMN17, u.TRIALCOLUMN18, u.TRIALCOLUMN19, u.TRIALCOLUMN20, u.TRIALCOLUMN21, u.TRIALCOLUMN22, u.TRIALCOLUMN23, u.TRIALCOLUMN24, u.TRIALCOLUMN25, u.TRIALCOLUMN26, u.TRIALCOLUMN27, u.TRIALCOLUMN28, u.TRIALCOLUMN29, u.TRIALCOLUMN30, u.TRIALCOLUMN31, u.TRIALCOLUMN32)
	err = db.QueryRow(sqlstr, u.UserName, u.FirstName, u.LastName, u.About, u.TRIALCOLUMN6, u.TRIALCOLUMN7, u.TRIALCOLUMN8, u.TRIALCOLUMN9, u.TRIALCOLUMN10, u.TRIALCOLUMN11, u.TRIALCOLUMN12, u.TRIALCOLUMN13, u.TRIALCOLUMN14, u.TRIALCOLUMN15, u.TRIALCOLUMN16, u.TRIALCOLUMN17, u.TRIALCOLUMN18, u.TRIALCOLUMN19, u.TRIALCOLUMN20, u.TRIALCOLUMN21, u.TRIALCOLUMN22, u.TRIALCOLUMN23, u.TRIALCOLUMN24, u.TRIALCOLUMN25, u.TRIALCOLUMN26, u.TRIALCOLUMN27, u.TRIALCOLUMN28, u.TRIALCOLUMN29, u.TRIALCOLUMN30, u.TRIALCOLUMN31, u.TRIALCOLUMN32).Scan(&u.Id)
	if err != nil {
		return err
	}

	// set existence
	u._exists = true

	return nil
}

// Update updates the User in the database.
func (u *User) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !u._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if u._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.user SET (` +
		`UserName, FirstName, LastName, About, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10, TRIAL_COLUMN11, TRIAL_COLUMN12, TRIAL_COLUMN13, TRIAL_COLUMN14, TRIAL_COLUMN15, TRIAL_COLUMN16, TRIAL_COLUMN17, TRIAL_COLUMN18, TRIAL_COLUMN19, TRIAL_COLUMN20, TRIAL_COLUMN21, TRIAL_COLUMN22, TRIAL_COLUMN23, TRIAL_COLUMN24, TRIAL_COLUMN25, TRIAL_COLUMN26, TRIAL_COLUMN27, TRIAL_COLUMN28, TRIAL_COLUMN29, TRIAL_COLUMN30, TRIAL_COLUMN31, TRIAL_COLUMN32` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31` +
		`) WHERE Id = $32`

	// run query
	XOLog(sqlstr, u.UserName, u.FirstName, u.LastName, u.About, u.TRIALCOLUMN6, u.TRIALCOLUMN7, u.TRIALCOLUMN8, u.TRIALCOLUMN9, u.TRIALCOLUMN10, u.TRIALCOLUMN11, u.TRIALCOLUMN12, u.TRIALCOLUMN13, u.TRIALCOLUMN14, u.TRIALCOLUMN15, u.TRIALCOLUMN16, u.TRIALCOLUMN17, u.TRIALCOLUMN18, u.TRIALCOLUMN19, u.TRIALCOLUMN20, u.TRIALCOLUMN21, u.TRIALCOLUMN22, u.TRIALCOLUMN23, u.TRIALCOLUMN24, u.TRIALCOLUMN25, u.TRIALCOLUMN26, u.TRIALCOLUMN27, u.TRIALCOLUMN28, u.TRIALCOLUMN29, u.TRIALCOLUMN30, u.TRIALCOLUMN31, u.TRIALCOLUMN32, u.Id)
	_, err = db.Exec(sqlstr, u.UserName, u.FirstName, u.LastName, u.About, u.TRIALCOLUMN6, u.TRIALCOLUMN7, u.TRIALCOLUMN8, u.TRIALCOLUMN9, u.TRIALCOLUMN10, u.TRIALCOLUMN11, u.TRIALCOLUMN12, u.TRIALCOLUMN13, u.TRIALCOLUMN14, u.TRIALCOLUMN15, u.TRIALCOLUMN16, u.TRIALCOLUMN17, u.TRIALCOLUMN18, u.TRIALCOLUMN19, u.TRIALCOLUMN20, u.TRIALCOLUMN21, u.TRIALCOLUMN22, u.TRIALCOLUMN23, u.TRIALCOLUMN24, u.TRIALCOLUMN25, u.TRIALCOLUMN26, u.TRIALCOLUMN27, u.TRIALCOLUMN28, u.TRIALCOLUMN29, u.TRIALCOLUMN30, u.TRIALCOLUMN31, u.TRIALCOLUMN32, u.Id)
	return err
}

// Save saves the User to the database.
func (u *User) Save(db XODB) error {
	if u.Exists() {
		return u.Update(db)
	}

	return u.Insert(db)
}

// Upsert performs an upsert for User.
//
// NOTE: PostgreSQL 9.5+ only
func (u *User) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if u._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.user (` +
		`Id, UserName, FirstName, LastName, About, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10, TRIAL_COLUMN11, TRIAL_COLUMN12, TRIAL_COLUMN13, TRIAL_COLUMN14, TRIAL_COLUMN15, TRIAL_COLUMN16, TRIAL_COLUMN17, TRIAL_COLUMN18, TRIAL_COLUMN19, TRIAL_COLUMN20, TRIAL_COLUMN21, TRIAL_COLUMN22, TRIAL_COLUMN23, TRIAL_COLUMN24, TRIAL_COLUMN25, TRIAL_COLUMN26, TRIAL_COLUMN27, TRIAL_COLUMN28, TRIAL_COLUMN29, TRIAL_COLUMN30, TRIAL_COLUMN31, TRIAL_COLUMN32` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32` +
		`) ON CONFLICT (Id) DO UPDATE SET (` +
		`Id, UserName, FirstName, LastName, About, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10, TRIAL_COLUMN11, TRIAL_COLUMN12, TRIAL_COLUMN13, TRIAL_COLUMN14, TRIAL_COLUMN15, TRIAL_COLUMN16, TRIAL_COLUMN17, TRIAL_COLUMN18, TRIAL_COLUMN19, TRIAL_COLUMN20, TRIAL_COLUMN21, TRIAL_COLUMN22, TRIAL_COLUMN23, TRIAL_COLUMN24, TRIAL_COLUMN25, TRIAL_COLUMN26, TRIAL_COLUMN27, TRIAL_COLUMN28, TRIAL_COLUMN29, TRIAL_COLUMN30, TRIAL_COLUMN31, TRIAL_COLUMN32` +
		`) = (` +
		`EXCLUDED.Id, EXCLUDED.UserName, EXCLUDED.FirstName, EXCLUDED.LastName, EXCLUDED.About, EXCLUDED.TRIAL_COLUMN6, EXCLUDED.TRIAL_COLUMN7, EXCLUDED.TRIAL_COLUMN8, EXCLUDED.TRIAL_COLUMN9, EXCLUDED.TRIAL_COLUMN10, EXCLUDED.TRIAL_COLUMN11, EXCLUDED.TRIAL_COLUMN12, EXCLUDED.TRIAL_COLUMN13, EXCLUDED.TRIAL_COLUMN14, EXCLUDED.TRIAL_COLUMN15, EXCLUDED.TRIAL_COLUMN16, EXCLUDED.TRIAL_COLUMN17, EXCLUDED.TRIAL_COLUMN18, EXCLUDED.TRIAL_COLUMN19, EXCLUDED.TRIAL_COLUMN20, EXCLUDED.TRIAL_COLUMN21, EXCLUDED.TRIAL_COLUMN22, EXCLUDED.TRIAL_COLUMN23, EXCLUDED.TRIAL_COLUMN24, EXCLUDED.TRIAL_COLUMN25, EXCLUDED.TRIAL_COLUMN26, EXCLUDED.TRIAL_COLUMN27, EXCLUDED.TRIAL_COLUMN28, EXCLUDED.TRIAL_COLUMN29, EXCLUDED.TRIAL_COLUMN30, EXCLUDED.TRIAL_COLUMN31, EXCLUDED.TRIAL_COLUMN32` +
		`)`

	// run query
	XOLog(sqlstr, u.Id, u.UserName, u.FirstName, u.LastName, u.About, u.TRIALCOLUMN6, u.TRIALCOLUMN7, u.TRIALCOLUMN8, u.TRIALCOLUMN9, u.TRIALCOLUMN10, u.TRIALCOLUMN11, u.TRIALCOLUMN12, u.TRIALCOLUMN13, u.TRIALCOLUMN14, u.TRIALCOLUMN15, u.TRIALCOLUMN16, u.TRIALCOLUMN17, u.TRIALCOLUMN18, u.TRIALCOLUMN19, u.TRIALCOLUMN20, u.TRIALCOLUMN21, u.TRIALCOLUMN22, u.TRIALCOLUMN23, u.TRIALCOLUMN24, u.TRIALCOLUMN25, u.TRIALCOLUMN26, u.TRIALCOLUMN27, u.TRIALCOLUMN28, u.TRIALCOLUMN29, u.TRIALCOLUMN30, u.TRIALCOLUMN31, u.TRIALCOLUMN32)
	_, err = db.Exec(sqlstr, u.Id, u.UserName, u.FirstName, u.LastName, u.About, u.TRIALCOLUMN6, u.TRIALCOLUMN7, u.TRIALCOLUMN8, u.TRIALCOLUMN9, u.TRIALCOLUMN10, u.TRIALCOLUMN11, u.TRIALCOLUMN12, u.TRIALCOLUMN13, u.TRIALCOLUMN14, u.TRIALCOLUMN15, u.TRIALCOLUMN16, u.TRIALCOLUMN17, u.TRIALCOLUMN18, u.TRIALCOLUMN19, u.TRIALCOLUMN20, u.TRIALCOLUMN21, u.TRIALCOLUMN22, u.TRIALCOLUMN23, u.TRIALCOLUMN24, u.TRIALCOLUMN25, u.TRIALCOLUMN26, u.TRIALCOLUMN27, u.TRIALCOLUMN28, u.TRIALCOLUMN29, u.TRIALCOLUMN30, u.TRIALCOLUMN31, u.TRIALCOLUMN32)
	if err != nil {
		return err
	}

	// set existence
	u._exists = true

	return nil
}

// Delete deletes the User from the database.
func (u *User) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !u._exists {
		return nil
	}

	// if deleted, bail
	if u._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.user WHERE Id = $1`

	// run query
	XOLog(sqlstr, u.Id)
	_, err = db.Exec(sqlstr, u.Id)
	if err != nil {
		return err
	}

	// set deleted
	u._deleted = true

	return nil
}

// UserMetaInfo represents a row from 'public.user_meta_info'.
type UserMetaInfo struct {
	UserId              int   `json:"UserId"`              // UserId
	IsNotificationDirty int16 `json:"IsNotificationDirty"` // IsNotificationDirty

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the UserMetaInfo exists in the database.
func (umi *UserMetaInfo) Exists() bool {
	return umi._exists
}

// Deleted provides information if the UserMetaInfo has been deleted from the database.
func (umi *UserMetaInfo) Deleted() bool {
	return umi._deleted
}

// Insert inserts the UserMetaInfo to the database.
func (umi *UserMetaInfo) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if umi._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.user_meta_info (` +
		`IsNotificationDirty` +
		`) VALUES (` +
		`$1` +
		`) RETURNING UserId`

	// run query
	XOLog(sqlstr, umi.IsNotificationDirty)
	err = db.QueryRow(sqlstr, umi.IsNotificationDirty).Scan(&umi.UserId)
	if err != nil {
		return err
	}

	// set existence
	umi._exists = true

	return nil
}

// Update updates the UserMetaInfo in the database.
func (umi *UserMetaInfo) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !umi._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if umi._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.user_meta_info SET (` +
		`IsNotificationDirty` +
		`) = ( ` +
		`$1` +
		`) WHERE UserId = $2`

	// run query
	XOLog(sqlstr, umi.IsNotificationDirty, umi.UserId)
	_, err = db.Exec(sqlstr, umi.IsNotificationDirty, umi.UserId)
	return err
}

// Save saves the UserMetaInfo to the database.
func (umi *UserMetaInfo) Save(db XODB) error {
	if umi.Exists() {
		return umi.Update(db)
	}

	return umi.Insert(db)
}

// Upsert performs an upsert for UserMetaInfo.
//
// NOTE: PostgreSQL 9.5+ only
func (umi *UserMetaInfo) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if umi._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.user_meta_info (` +
		`UserId, IsNotificationDirty` +
		`) VALUES (` +
		`$1, $2` +
		`) ON CONFLICT (UserId) DO UPDATE SET (` +
		`UserId, IsNotificationDirty` +
		`) = (` +
		`EXCLUDED.UserId, EXCLUDED.IsNotificationDirty` +
		`)`

	// run query
	XOLog(sqlstr, umi.UserId, umi.IsNotificationDirty)
	_, err = db.Exec(sqlstr, umi.UserId, umi.IsNotificationDirty)
	if err != nil {
		return err
	}

	// set existence
	umi._exists = true

	return nil
}

// Delete deletes the UserMetaInfo from the database.
func (umi *UserMetaInfo) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !umi._exists {
		return nil
	}

	// if deleted, bail
	if umi._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.user_meta_info WHERE UserId = $1`

	// run query
	XOLog(sqlstr, umi.UserId)
	_, err = db.Exec(sqlstr, umi.UserId)
	if err != nil {
		return err
	}

	// set deleted
	umi._deleted = true

	return nil
}

// UserPassword represents a row from 'public.user_password'.
type UserPassword struct {
	UserId      int    `json:"UserId"`      // UserId
	Password    string `json:"Password"`    // Password
	CreatedTime int    `json:"CreatedTime"` // CreatedTime

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the UserPassword exists in the database.
func (up *UserPassword) Exists() bool {
	return up._exists
}

// Deleted provides information if the UserPassword has been deleted from the database.
func (up *UserPassword) Deleted() bool {
	return up._deleted
}

// Insert inserts the UserPassword to the database.
func (up *UserPassword) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if up._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.user_password (` +
		`Password, CreatedTime` +
		`) VALUES (` +
		`$1, $2` +
		`) RETURNING UserId`

	// run query
	XOLog(sqlstr, up.Password, up.CreatedTime)
	err = db.QueryRow(sqlstr, up.Password, up.CreatedTime).Scan(&up.UserId)
	if err != nil {
		return err
	}

	// set existence
	up._exists = true

	return nil
}

// Update updates the UserPassword in the database.
func (up *UserPassword) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !up._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if up._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.user_password SET (` +
		`Password, CreatedTime` +
		`) = ( ` +
		`$1, $2` +
		`) WHERE UserId = $3`

	// run query
	XOLog(sqlstr, up.Password, up.CreatedTime, up.UserId)
	_, err = db.Exec(sqlstr, up.Password, up.CreatedTime, up.UserId)
	return err
}

// Save saves the UserPassword to the database.
func (up *UserPassword) Save(db XODB) error {
	if up.Exists() {
		return up.Update(db)
	}

	return up.Insert(db)
}

// Upsert performs an upsert for UserPassword.
//
// NOTE: PostgreSQL 9.5+ only
func (up *UserPassword) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if up._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.user_password (` +
		`UserId, Password, CreatedTime` +
		`) VALUES (` +
		`$1, $2, $3` +
		`) ON CONFLICT (UserId) DO UPDATE SET (` +
		`UserId, Password, CreatedTime` +
		`) = (` +
		`EXCLUDED.UserId, EXCLUDED.Password, EXCLUDED.CreatedTime` +
		`)`

	// run query
	XOLog(sqlstr, up.UserId, up.Password, up.CreatedTime)
	_, err = db.Exec(sqlstr, up.UserId, up.Password, up.CreatedTime)
	if err != nil {
		return err
	}

	// set existence
	up._exists = true

	return nil
}

// Delete deletes the UserPassword from the database.
func (up *UserPassword) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !up._exists {
		return nil
	}

	// if deleted, bail
	if up._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.user_password WHERE UserId = $1`

	// run query
	XOLog(sqlstr, up.UserId)
	_, err = db.Exec(sqlstr, up.UserId)
	if err != nil {
		return err
	}

	// set deleted
	up._deleted = true

	return nil
}

// CommentsByPostId retrieves a row from 'public.comments' as a Comment.
//
// Generated from index 'PostId'.
func CommentsByPostId(db XODB, postId int) ([]*Comment, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, UserId, PostId, Text, CreatedTime ` +
		`FROM public.comments ` +
		`WHERE PostId = $1`

	// run query
	XOLog(sqlstr, postId)
	q, err := db.Query(sqlstr, postId)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Comment{}
	for q.Next() {
		c := Comment{
			_exists: true,
		}

		// scan
		err = q.Scan(&c.Id, &c.UserId, &c.PostId, &c.Text, &c.CreatedTime)
		if err != nil {
			return nil, err
		}

		res = append(res, &c)
	}

	return res, nil
}

// CommentById retrieves a row from 'public.comments' as a Comment.
//
// Generated from index 'comments_pkey'.
func CommentById(db XODB, id int) (*Comment, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, UserId, PostId, Text, CreatedTime ` +
		`FROM public.comments ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	c := Comment{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&c.Id, &c.UserId, &c.PostId, &c.Text, &c.CreatedTime)
	if err != nil {
		return nil, err
	}

	return &c, nil
}

// FollowingListByIdUserId retrieves a row from 'public.following_list' as a FollowingList.
//
// Generated from index 'following_list_pkey'.
func FollowingListByIdUserId(db XODB, id int, userId int) (*FollowingList, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, UserId, ListType, Name, Count, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8 ` +
		`FROM public.following_list ` +
		`WHERE Id = $1 AND UserId = $2`

	// run query
	XOLog(sqlstr, id, userId)
	fl := FollowingList{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id, userId).Scan(&fl.Id, &fl.UserId, &fl.ListType, &fl.Name, &fl.Count, &fl.TRIALCOLUMN6, &fl.TRIALCOLUMN7, &fl.TRIALCOLUMN8)
	if err != nil {
		return nil, err
	}

	return &fl, nil
}

// FollowingListMembersByFollowedUserIdUserId retrieves a row from 'public.following_list_member' as a FollowingListMember.
//
// Generated from index 'FollowedUserId'.
func FollowingListMembersByFollowedUserIdUserId(db XODB, followedUserId int, userId int) ([]*FollowingListMember, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, ListId, UserId, FollowedUserId, FollowType, TRIAL_COLUMN6 ` +
		`FROM public.following_list_member ` +
		`WHERE FollowedUserId = $1 AND UserId = $2`

	// run query
	XOLog(sqlstr, followedUserId, userId)
	q, err := db.Query(sqlstr, followedUserId, userId)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*FollowingListMember{}
	for q.Next() {
		flm := FollowingListMember{
			_exists: true,
		}

		// scan
		err = q.Scan(&flm.Id, &flm.ListId, &flm.UserId, &flm.FollowedUserId, &flm.FollowType, &flm.TRIALCOLUMN6)
		if err != nil {
			return nil, err
		}

		res = append(res, &flm)
	}

	return res, nil
}

// FollowingListMemberByUserIdFollowedUserId retrieves a row from 'public.following_list_member' as a FollowingListMember.
//
// Generated from index 'UserId'.
func FollowingListMemberByUserIdFollowedUserId(db XODB, userId int, followedUserId int) (*FollowingListMember, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, ListId, UserId, FollowedUserId, FollowType, TRIAL_COLUMN6 ` +
		`FROM public.following_list_member ` +
		`WHERE UserId = $1 AND FollowedUserId = $2`

	// run query
	XOLog(sqlstr, userId, followedUserId)
	flm := FollowingListMember{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, userId, followedUserId).Scan(&flm.Id, &flm.ListId, &flm.UserId, &flm.FollowedUserId, &flm.FollowType, &flm.TRIALCOLUMN6)
	if err != nil {
		return nil, err
	}

	return &flm, nil
}

// FollowingListMemberById retrieves a row from 'public.following_list_member' as a FollowingListMember.
//
// Generated from index 'following_list_member_pkey'.
func FollowingListMemberById(db XODB, id int64) (*FollowingListMember, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, ListId, UserId, FollowedUserId, FollowType, TRIAL_COLUMN6 ` +
		`FROM public.following_list_member ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	flm := FollowingListMember{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&flm.Id, &flm.ListId, &flm.UserId, &flm.FollowedUserId, &flm.FollowType, &flm.TRIALCOLUMN6)
	if err != nil {
		return nil, err
	}

	return &flm, nil
}

// FollowingListMemberHistoryById retrieves a row from 'public.following_list_member_history' as a FollowingListMemberHistory.
//
// Generated from index 'following_list_member_history_pkey'.
func FollowingListMemberHistoryById(db XODB, id int64) (*FollowingListMemberHistory, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, ListId, UserId, FollowedUserId, FollowType, TRIAL_COLUMN6, TRIAL_COLUMN7 ` +
		`FROM public.following_list_member_history ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	flmh := FollowingListMemberHistory{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&flmh.Id, &flmh.ListId, &flmh.UserId, &flmh.FollowedUserId, &flmh.FollowType, &flmh.TRIALCOLUMN6, &flmh.TRIALCOLUMN7)
	if err != nil {
		return nil, err
	}

	return &flmh, nil
}

// LikeById retrieves a row from 'public.likes' as a Like.
//
// Generated from index 'likes_pkey'.
func LikeById(db XODB, id int) (*Like, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, PostId, UserId, TypeId, CreatedTime ` +
		`FROM public.likes ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	l := Like{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&l.Id, &l.PostId, &l.UserId, &l.TypeId, &l.CreatedTime)
	if err != nil {
		return nil, err
	}

	return &l, nil
}

// MediaById retrieves a row from 'public.media' as a Media.
//
// Generated from index 'media_pkey'.
func MediaById(db XODB, id int) (*Media, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, UserId, PostId, AlbumId, TypeId, TRIAL_COLUMN6, TRIAL_COLUMN7 ` +
		`FROM public.media ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	m := Media{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&m.Id, &m.UserId, &m.PostId, &m.AlbumId, &m.TypeId, &m.TRIALCOLUMN6, &m.TRIALCOLUMN7)
	if err != nil {
		return nil, err
	}

	return &m, nil
}

// MessagesByToUserId retrieves a row from 'public.message' as a Message.
//
// Generated from index 'ToUserId'.
func MessagesByToUserId(db XODB, toUserId int) ([]*Message, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, ToUserId, RoomKey, MessageKey, FromUserID, TRIAL_COLUMN6, TRIAL_COLUMN7 ` +
		`FROM public.message ` +
		`WHERE ToUserId = $1`

	// run query
	XOLog(sqlstr, toUserId)
	q, err := db.Query(sqlstr, toUserId)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Message{}
	for q.Next() {
		m := Message{
			_exists: true,
		}

		// scan
		err = q.Scan(&m.Id, &m.ToUserId, &m.RoomKey, &m.MessageKey, &m.FromUserID, &m.TRIALCOLUMN6, &m.TRIALCOLUMN7)
		if err != nil {
			return nil, err
		}

		res = append(res, &m)
	}

	return res, nil
}

// MessageById retrieves a row from 'public.message' as a Message.
//
// Generated from index 'message_pkey'.
func MessageById(db XODB, id int64) (*Message, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, ToUserId, RoomKey, MessageKey, FromUserID, TRIAL_COLUMN6, TRIAL_COLUMN7 ` +
		`FROM public.message ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	m := Message{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&m.Id, &m.ToUserId, &m.RoomKey, &m.MessageKey, &m.FromUserID, &m.TRIALCOLUMN6, &m.TRIALCOLUMN7)
	if err != nil {
		return nil, err
	}

	return &m, nil
}

// MsgDeletedFromServerById retrieves a row from 'public.msg_deleted_from_server' as a MsgDeletedFromServer.
//
// Generated from index 'msg_deleted_from_server_pkey'.
func MsgDeletedFromServerById(db XODB, id int64) (*MsgDeletedFromServer, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, ToUserId, MsgKey, PeerUserId, RoomKey, TRIAL_COLUMN6 ` +
		`FROM public.msg_deleted_from_server ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	mdfs := MsgDeletedFromServer{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&mdfs.Id, &mdfs.ToUserId, &mdfs.MsgKey, &mdfs.PeerUserId, &mdfs.RoomKey, &mdfs.TRIALCOLUMN6)
	if err != nil {
		return nil, err
	}

	return &mdfs, nil
}

// MsgReceivedToPeerById retrieves a row from 'public.msg_received_to_peer' as a MsgReceivedToPeer.
//
// Generated from index 'msg_received_to_peer_pkey'.
func MsgReceivedToPeerById(db XODB, id int64) (*MsgReceivedToPeer, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, ToUserId, MsgKey, RoomKey, PeerUserId, TRIAL_COLUMN6 ` +
		`FROM public.msg_received_to_peer ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	mrtp := MsgReceivedToPeer{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&mrtp.Id, &mrtp.ToUserId, &mrtp.MsgKey, &mrtp.RoomKey, &mrtp.PeerUserId, &mrtp.TRIALCOLUMN6)
	if err != nil {
		return nil, err
	}

	return &mrtp, nil
}

// MsgSeenByPeerById retrieves a row from 'public.msg_seen_by_peer' as a MsgSeenByPeer.
//
// Generated from index 'msg_seen_by_peer_pkey'.
func MsgSeenByPeerById(db XODB, id int64) (*MsgSeenByPeer, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, ToUserId, MsgKey, RoomKey, PeerUserId, TRIAL_COLUMN6 ` +
		`FROM public.msg_seen_by_peer ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	msbp := MsgSeenByPeer{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&msbp.Id, &msbp.ToUserId, &msbp.MsgKey, &msbp.RoomKey, &msbp.PeerUserId, &msbp.TRIALCOLUMN6)
	if err != nil {
		return nil, err
	}

	return &msbp, nil
}

// NotificationByForUserIdId retrieves a row from 'public.notification' as a Notification.
//
// Generated from index 'ForUserId'.
func NotificationByForUserIdId(db XODB, forUserId int, id int) (*Notification, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, ForUserId, ActorUserId, ActionTypeId, ObjectTypeId, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9 ` +
		`FROM public.notification ` +
		`WHERE ForUserId = $1 AND Id = $2`

	// run query
	XOLog(sqlstr, forUserId, id)
	n := Notification{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, forUserId, id).Scan(&n.Id, &n.ForUserId, &n.ActorUserId, &n.ActionTypeId, &n.ObjectTypeId, &n.TRIALCOLUMN6, &n.TRIALCOLUMN7, &n.TRIALCOLUMN8, &n.TRIALCOLUMN9)
	if err != nil {
		return nil, err
	}

	return &n, nil
}

// NotificationById retrieves a row from 'public.notification' as a Notification.
//
// Generated from index 'notification_pkey'.
func NotificationById(db XODB, id int) (*Notification, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, ForUserId, ActorUserId, ActionTypeId, ObjectTypeId, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9 ` +
		`FROM public.notification ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	n := Notification{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&n.Id, &n.ForUserId, &n.ActorUserId, &n.ActionTypeId, &n.ObjectTypeId, &n.TRIALCOLUMN6, &n.TRIALCOLUMN7, &n.TRIALCOLUMN8, &n.TRIALCOLUMN9)
	if err != nil {
		return nil, err
	}

	return &n, nil
}

// NotificationRemovedByNotificationId retrieves a row from 'public.notification_removed' as a NotificationRemoved.
//
// Generated from index 'notification_removed_pkey'.
func NotificationRemovedByNotificationId(db XODB, notificationId int) (*NotificationRemoved, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`NotificationId, ForUserId ` +
		`FROM public.notification_removed ` +
		`WHERE NotificationId = $1`

	// run query
	XOLog(sqlstr, notificationId)
	nr := NotificationRemoved{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, notificationId).Scan(&nr.NotificationId, &nr.ForUserId)
	if err != nil {
		return nil, err
	}

	return &nr, nil
}

// PhoneContactsByPhoneNormalizedNumber retrieves a row from 'public.phone_contacts' as a PhoneContact.
//
// Generated from index 'PhoneNormalizedNumber'.
func PhoneContactsByPhoneNormalizedNumber(db XODB, phoneNormalizedNumber string) ([]*PhoneContact, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, PhoneDisplayName, PhoneFamilyName, PhoneNumber, PhoneNormalizedNumber, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10 ` +
		`FROM public.phone_contacts ` +
		`WHERE PhoneNormalizedNumber = $1`

	// run query
	XOLog(sqlstr, phoneNormalizedNumber)
	q, err := db.Query(sqlstr, phoneNormalizedNumber)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*PhoneContact{}
	for q.Next() {
		pc := PhoneContact{
			_exists: true,
		}

		// scan
		err = q.Scan(&pc.Id, &pc.PhoneDisplayName, &pc.PhoneFamilyName, &pc.PhoneNumber, &pc.PhoneNormalizedNumber, &pc.TRIALCOLUMN6, &pc.TRIALCOLUMN7, &pc.TRIALCOLUMN8, &pc.TRIALCOLUMN9, &pc.TRIALCOLUMN10)
		if err != nil {
			return nil, err
		}

		res = append(res, &pc)
	}

	return res, nil
}

// PhoneContactsByPhoneNumber retrieves a row from 'public.phone_contacts' as a PhoneContact.
//
// Generated from index 'PhoneNumber'.
func PhoneContactsByPhoneNumber(db XODB, phoneNumber string) ([]*PhoneContact, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, PhoneDisplayName, PhoneFamilyName, PhoneNumber, PhoneNormalizedNumber, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10 ` +
		`FROM public.phone_contacts ` +
		`WHERE PhoneNumber = $1`

	// run query
	XOLog(sqlstr, phoneNumber)
	q, err := db.Query(sqlstr, phoneNumber)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*PhoneContact{}
	for q.Next() {
		pc := PhoneContact{
			_exists: true,
		}

		// scan
		err = q.Scan(&pc.Id, &pc.PhoneDisplayName, &pc.PhoneFamilyName, &pc.PhoneNumber, &pc.PhoneNormalizedNumber, &pc.TRIALCOLUMN6, &pc.TRIALCOLUMN7, &pc.TRIALCOLUMN8, &pc.TRIALCOLUMN9, &pc.TRIALCOLUMN10)
		if err != nil {
			return nil, err
		}

		res = append(res, &pc)
	}

	return res, nil
}

// PhoneContactById retrieves a row from 'public.phone_contacts' as a PhoneContact.
//
// Generated from index 'phone_contacts_pkey'.
func PhoneContactById(db XODB, id int) (*PhoneContact, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, PhoneDisplayName, PhoneFamilyName, PhoneNumber, PhoneNormalizedNumber, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10 ` +
		`FROM public.phone_contacts ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	pc := PhoneContact{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&pc.Id, &pc.PhoneDisplayName, &pc.PhoneFamilyName, &pc.PhoneNumber, &pc.PhoneNormalizedNumber, &pc.TRIALCOLUMN6, &pc.TRIALCOLUMN7, &pc.TRIALCOLUMN8, &pc.TRIALCOLUMN9, &pc.TRIALCOLUMN10)
	if err != nil {
		return nil, err
	}

	return &pc, nil
}

// PostById retrieves a row from 'public.post' as a Post.
//
// Generated from index 'post_pkey'.
func PostById(db XODB, id int) (*Post, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, UserId, TypeId, Text, FormatedText, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10, TRIAL_COLUMN11, TRIAL_COLUMN12, TRIAL_COLUMN13, TRIAL_COLUMN14 ` +
		`FROM public.post ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	p := Post{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&p.Id, &p.UserId, &p.TypeId, &p.Text, &p.FormatedText, &p.TRIALCOLUMN6, &p.TRIALCOLUMN7, &p.TRIALCOLUMN8, &p.TRIALCOLUMN9, &p.TRIALCOLUMN10, &p.TRIALCOLUMN11, &p.TRIALCOLUMN12, &p.TRIALCOLUMN13, &p.TRIALCOLUMN14)
	if err != nil {
		return nil, err
	}

	return &p, nil
}

// RecommendUserById retrieves a row from 'public.recommend_user' as a RecommendUser.
//
// Generated from index 'recommend_user_pkey'.
func RecommendUserById(db XODB, id int) (*RecommendUser, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, UserId, TargetId, Weight, CreatedTime ` +
		`FROM public.recommend_user ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	ru := RecommendUser{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&ru.Id, &ru.UserId, &ru.TargetId, &ru.Weight, &ru.CreatedTime)
	if err != nil {
		return nil, err
	}

	return &ru, nil
}

// SearchClickedById retrieves a row from 'public.search_clicked' as a SearchClicked.
//
// Generated from index 'search_clicked_pkey'.
func SearchClickedById(db XODB, id int64) (*SearchClicked, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, Query, ClickType, TargetId, UserId, TRIAL_COLUMN6 ` +
		`FROM public.search_clicked ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	sc := SearchClicked{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&sc.Id, &sc.Query, &sc.ClickType, &sc.TargetId, &sc.UserId, &sc.TRIALCOLUMN6)
	if err != nil {
		return nil, err
	}

	return &sc, nil
}

// SessionsById retrieves a row from 'public.session' as a Session.
//
// Generated from index 'Id'.
func SessionsById(db XODB, id int) ([]*Session, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, UserId, SessionUuid, ClientUuid, DeviceUuid, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10 ` +
		`FROM public.session ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	q, err := db.Query(sqlstr, id)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Session{}
	for q.Next() {
		s := Session{
			_exists: true,
		}

		// scan
		err = q.Scan(&s.Id, &s.UserId, &s.SessionUuid, &s.ClientUuid, &s.DeviceUuid, &s.TRIALCOLUMN6, &s.TRIALCOLUMN7, &s.TRIALCOLUMN8, &s.TRIALCOLUMN9, &s.TRIALCOLUMN10)
		if err != nil {
			return nil, err
		}

		res = append(res, &s)
	}

	return res, nil
}

// SessionById retrieves a row from 'public.session' as a Session.
//
// Generated from index 'session_pkey'.
func SessionById(db XODB, id int) (*Session, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, UserId, SessionUuid, ClientUuid, DeviceUuid, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10 ` +
		`FROM public.session ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	s := Session{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&s.Id, &s.UserId, &s.SessionUuid, &s.ClientUuid, &s.DeviceUuid, &s.TRIALCOLUMN6, &s.TRIALCOLUMN7, &s.TRIALCOLUMN8, &s.TRIALCOLUMN9, &s.TRIALCOLUMN10)
	if err != nil {
		return nil, err
	}

	return &s, nil
}

// TagByName retrieves a row from 'public.tags' as a Tag.
//
// Generated from index 'Name'.
func TagByName(db XODB, name string) (*Tag, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, Name, Count, IsBlocked, CreatedTime ` +
		`FROM public.tags ` +
		`WHERE Name = $1`

	// run query
	XOLog(sqlstr, name)
	t := Tag{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, name).Scan(&t.Id, &t.Name, &t.Count, &t.IsBlocked, &t.CreatedTime)
	if err != nil {
		return nil, err
	}

	return &t, nil
}

// TagById retrieves a row from 'public.tags' as a Tag.
//
// Generated from index 'tags_pkey'.
func TagById(db XODB, id int) (*Tag, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, Name, Count, IsBlocked, CreatedTime ` +
		`FROM public.tags ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	t := Tag{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&t.Id, &t.Name, &t.Count, &t.IsBlocked, &t.CreatedTime)
	if err != nil {
		return nil, err
	}

	return &t, nil
}

// TagsPostByTagIdPostId retrieves a row from 'public.tags_posts' as a TagsPost.
//
// Generated from index 'TagId'.
func TagsPostByTagIdPostId(db XODB, tagId int, postId int) (*TagsPost, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, TagId, PostId, TypeId, CreatedTime ` +
		`FROM public.tags_posts ` +
		`WHERE TagId = $1 AND PostId = $2`

	// run query
	XOLog(sqlstr, tagId, postId)
	tp := TagsPost{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, tagId, postId).Scan(&tp.Id, &tp.TagId, &tp.PostId, &tp.TypeId, &tp.CreatedTime)
	if err != nil {
		return nil, err
	}

	return &tp, nil
}

// TagsPostById retrieves a row from 'public.tags_posts' as a TagsPost.
//
// Generated from index 'tags_posts_pkey'.
func TagsPostById(db XODB, id int) (*TagsPost, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, TagId, PostId, TypeId, CreatedTime ` +
		`FROM public.tags_posts ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	tp := TagsPost{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&tp.Id, &tp.TagId, &tp.PostId, &tp.TypeId, &tp.CreatedTime)
	if err != nil {
		return nil, err
	}

	return &tp, nil
}

// UserByUserName retrieves a row from 'public.user' as a User.
//
// Generated from index 'UserName'.
func UserByUserName(db XODB, userName string) (*User, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, UserName, FirstName, LastName, About, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10, TRIAL_COLUMN11, TRIAL_COLUMN12, TRIAL_COLUMN13, TRIAL_COLUMN14, TRIAL_COLUMN15, TRIAL_COLUMN16, TRIAL_COLUMN17, TRIAL_COLUMN18, TRIAL_COLUMN19, TRIAL_COLUMN20, TRIAL_COLUMN21, TRIAL_COLUMN22, TRIAL_COLUMN23, TRIAL_COLUMN24, TRIAL_COLUMN25, TRIAL_COLUMN26, TRIAL_COLUMN27, TRIAL_COLUMN28, TRIAL_COLUMN29, TRIAL_COLUMN30, TRIAL_COLUMN31, TRIAL_COLUMN32 ` +
		`FROM public.user ` +
		`WHERE UserName = $1`

	// run query
	XOLog(sqlstr, userName)
	u := User{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, userName).Scan(&u.Id, &u.UserName, &u.FirstName, &u.LastName, &u.About, &u.TRIALCOLUMN6, &u.TRIALCOLUMN7, &u.TRIALCOLUMN8, &u.TRIALCOLUMN9, &u.TRIALCOLUMN10, &u.TRIALCOLUMN11, &u.TRIALCOLUMN12, &u.TRIALCOLUMN13, &u.TRIALCOLUMN14, &u.TRIALCOLUMN15, &u.TRIALCOLUMN16, &u.TRIALCOLUMN17, &u.TRIALCOLUMN18, &u.TRIALCOLUMN19, &u.TRIALCOLUMN20, &u.TRIALCOLUMN21, &u.TRIALCOLUMN22, &u.TRIALCOLUMN23, &u.TRIALCOLUMN24, &u.TRIALCOLUMN25, &u.TRIALCOLUMN26, &u.TRIALCOLUMN27, &u.TRIALCOLUMN28, &u.TRIALCOLUMN29, &u.TRIALCOLUMN30, &u.TRIALCOLUMN31, &u.TRIALCOLUMN32)
	if err != nil {
		return nil, err
	}

	return &u, nil
}

// UserById retrieves a row from 'public.user' as a User.
//
// Generated from index 'user_pkey'.
func UserById(db XODB, id int) (*User, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`Id, UserName, FirstName, LastName, About, TRIAL_COLUMN6, TRIAL_COLUMN7, TRIAL_COLUMN8, TRIAL_COLUMN9, TRIAL_COLUMN10, TRIAL_COLUMN11, TRIAL_COLUMN12, TRIAL_COLUMN13, TRIAL_COLUMN14, TRIAL_COLUMN15, TRIAL_COLUMN16, TRIAL_COLUMN17, TRIAL_COLUMN18, TRIAL_COLUMN19, TRIAL_COLUMN20, TRIAL_COLUMN21, TRIAL_COLUMN22, TRIAL_COLUMN23, TRIAL_COLUMN24, TRIAL_COLUMN25, TRIAL_COLUMN26, TRIAL_COLUMN27, TRIAL_COLUMN28, TRIAL_COLUMN29, TRIAL_COLUMN30, TRIAL_COLUMN31, TRIAL_COLUMN32 ` +
		`FROM public.user ` +
		`WHERE Id = $1`

	// run query
	XOLog(sqlstr, id)
	u := User{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&u.Id, &u.UserName, &u.FirstName, &u.LastName, &u.About, &u.TRIALCOLUMN6, &u.TRIALCOLUMN7, &u.TRIALCOLUMN8, &u.TRIALCOLUMN9, &u.TRIALCOLUMN10, &u.TRIALCOLUMN11, &u.TRIALCOLUMN12, &u.TRIALCOLUMN13, &u.TRIALCOLUMN14, &u.TRIALCOLUMN15, &u.TRIALCOLUMN16, &u.TRIALCOLUMN17, &u.TRIALCOLUMN18, &u.TRIALCOLUMN19, &u.TRIALCOLUMN20, &u.TRIALCOLUMN21, &u.TRIALCOLUMN22, &u.TRIALCOLUMN23, &u.TRIALCOLUMN24, &u.TRIALCOLUMN25, &u.TRIALCOLUMN26, &u.TRIALCOLUMN27, &u.TRIALCOLUMN28, &u.TRIALCOLUMN29, &u.TRIALCOLUMN30, &u.TRIALCOLUMN31, &u.TRIALCOLUMN32)
	if err != nil {
		return nil, err
	}

	return &u, nil
}

// UserMetaInfoByUserId retrieves a row from 'public.user_meta_info' as a UserMetaInfo.
//
// Generated from index 'user_meta_info_pkey'.
func UserMetaInfoByUserId(db XODB, userId int) (*UserMetaInfo, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`UserId, IsNotificationDirty ` +
		`FROM public.user_meta_info ` +
		`WHERE UserId = $1`

	// run query
	XOLog(sqlstr, userId)
	umi := UserMetaInfo{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, userId).Scan(&umi.UserId, &umi.IsNotificationDirty)
	if err != nil {
		return nil, err
	}

	return &umi, nil
}

// UserPasswordByUserId retrieves a row from 'public.user_password' as a UserPassword.
//
// Generated from index 'user_password_pkey'.
func UserPasswordByUserId(db XODB, userId int) (*UserPassword, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`UserId, Password, CreatedTime ` +
		`FROM public.user_password ` +
		`WHERE UserId = $1`

	// run query
	XOLog(sqlstr, userId)
	up := UserPassword{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, userId).Scan(&up.UserId, &up.Password, &up.CreatedTime)
	if err != nil {
		return nil, err
	}

	return &up, nil
}

// XODB is the common interface for database operations that can be used with
// types from schema 'public'.
//
// This should work with database/sql.DB and database/sql.Tx.
type XODB interface {
	Exec(string, ...interface{}) (sql.Result, error)
	Query(string, ...interface{}) (*sql.Rows, error)
	QueryRow(string, ...interface{}) *sql.Row
}

// XOLog provides the log func used by generated queries.
var XOLog = func(string, ...interface{}) {}

// ScannerValuer is the common interface for types that implement both the
// database/sql.Scanner and sql/driver.Valuer interfaces.
type ScannerValuer interface {
	sql.Scanner
	driver.Valuer
}

// StringSlice is a slice of strings.
type StringSlice []string

// quoteEscapeRegex is the regex to match escaped characters in a string.
var quoteEscapeRegex = regexp.MustCompile(`([^\\]([\\]{2})*)\\"`)

// Scan satisfies the sql.Scanner interface for StringSlice.
func (ss *StringSlice) Scan(src interface{}) error {
	buf, ok := src.([]byte)
	if !ok {
		return errors.New("invalid StringSlice")
	}

	// change quote escapes for csv parser
	str := quoteEscapeRegex.ReplaceAllString(string(buf), `$1""`)
	str = strings.Replace(str, `\\`, `\`, -1)

	// remove braces
	str = str[1 : len(str)-1]

	// bail if only one
	if len(str) == 0 {
		*ss = StringSlice([]string{})
		return nil
	}

	// parse with csv reader
	cr := csv.NewReader(strings.NewReader(str))
	slice, err := cr.Read()
	if err != nil {
		fmt.Printf("exiting!: %v\n", err)
		return err
	}

	*ss = StringSlice(slice)

	return nil
}

// Value satisfies the driver.Valuer interface for StringSlice.
func (ss StringSlice) Value() (driver.Value, error) {
	v := make([]string, len(ss))
	for i, s := range ss {
		v[i] = `"` + strings.Replace(strings.Replace(s, `\`, `\\\`, -1), `"`, `\"`, -1) + `"`
	}
	return "{" + strings.Join(v, ",") + "}", nil
}

// Slice is a slice of ScannerValuers.
type Slice []ScannerValuer
